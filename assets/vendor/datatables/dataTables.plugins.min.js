/*! RowReorder 1.5.0
 * © SpryMedia Ltd - datatables.net/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        var jq = require('jquery');
        var cjsRequires = function (root, $) {
            if (!$.fn.dataTable) {
                require('datatables.net')(root, $);
            }
        };

        if (typeof window === 'undefined') {
            module.exports = function (root, $) {
                if (!root) {
                    // CommonJS environments without a window global must pass a
                    // root. This will give an error otherwise
                    root = window;
                }

                if (!$) {
                    $ = jq(root);
                }

                cjsRequires(root, $);
                return factory($, root, root.document);
            };
        }
        else {
            cjsRequires(window, jq);
            module.exports = factory(jq, window, window.document);
        }
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;



    /**
     * @summary     RowReorder
     * @description Row reordering extension for DataTables
     * @version     1.5.0
     * @author      SpryMedia Ltd
     * @contact     datatables.net
     *
     * This source file is free software, available under the following license:
     *   MIT license - http://datatables.net/license/mit
     *
     * This source file is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
     *
     * For details please refer to: http://www.datatables.net
     */

    /**
     * RowReorder provides the ability in DataTables to click and drag rows to
     * reorder them. When a row is dropped the data for the rows effected will be
     * updated to reflect the change. Normally this data point should also be the
     * column being sorted upon in the DataTable but this does not need to be the
     * case. RowReorder implements a "data swap" method - so the rows being
     * reordered take the value of the data point from the row that used to occupy
     * the row's new position.
     *
     * Initialisation is done by either:
     *
     * * `rowReorder` parameter in the DataTable initialisation object
     * * `new DataTable.RowReorder( table, opts )` after DataTables
     *   initialisation.
     *
     *  @class
     *  @param {object} settings DataTables settings object for the host table
     *  @param {object} [opts] Configuration options
     *  @requires jQuery 1.7+
     *  @requires DataTables 1.11
     */
    var RowReorder = function (dt, opts) {
        // Sanity check that we are using DataTables 1.10 or newer
        if (!DataTable.versionCheck || !DataTable.versionCheck('1.11')) {
            throw 'DataTables RowReorder requires DataTables 1.11 or newer';
        }

        // User and defaults configuration object
        this.c = $.extend(true, {}, DataTable.defaults.rowReorder, RowReorder.defaults, opts);

        // Internal settings
        this.s = {
            /** @type {integer} Scroll body top cache */
            bodyTop: null,

            /** @type {DataTable.Api} DataTables' API instance */
            dt: new DataTable.Api(dt),

            /** @type {function} Data fetch function */
            getDataFn: DataTable.util.get(this.c.dataSrc),

            /** @type {array} Pixel positions for row insertion calculation */
            middles: null,

            /** @type {Object} Cached dimension information for use in the mouse move event handler */
            scroll: {},

            /** @type {integer} Interval object used for smooth scrolling */
            scrollInterval: null,

            /** @type {function} Data set function */
            setDataFn: DataTable.util.set(this.c.dataSrc),

            /** @type {Object} Mouse down information */
            start: {
                top: 0,
                left: 0,
                offsetTop: 0,
                offsetLeft: 0,
                nodes: [],
                rowIndex: 0
            },

            /** @type {integer} Window height cached value */
            windowHeight: 0,

            /** @type {integer} Document outer height cached value */
            documentOuterHeight: 0,

            /** @type {integer} DOM clone outer height cached value */
            domCloneOuterHeight: 0,

            /** @type {integer} Flag used for signing if the drop is enabled or not */
            dropAllowed: true
        };

        // DOM items
        this.dom = {
            /** @type {jQuery} Cloned row being moved around */
            clone: null,
            cloneParent: null,

            /** @type {jQuery} DataTables scrolling container */
            dtScroll: $('div.dataTables_scrollBody, div.dt-scroll-body', this.s.dt.table().container())
        };

        // Check if row reorder has already been initialised on this table
        var settings = this.s.dt.settings()[0];
        var existing = settings.rowreorder;

        if (existing) {
            return existing;
        }

        if (!this.dom.dtScroll.length) {
            this.dom.dtScroll = $(this.s.dt.table().container(), 'tbody');
        }

        settings.rowreorder = this;
        this._constructor();
    };

    $.extend(RowReorder.prototype, {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Constructor
         */

        /**
         * Initialise the RowReorder instance
         *
         * @private
         */
        _constructor: function () {
            var that = this;
            var dt = this.s.dt;
            var table = $(dt.table().node());

            // Need to be able to calculate the row positions relative to the table
            if (table.css('position') === 'static') {
                table.css('position', 'relative');
            }

            // listen for mouse down on the target column - we have to implement
            // this rather than using HTML5 drag and drop as drag and drop doesn't
            // appear to work on table rows at this time. Also mobile browsers are
            // not supported.
            // Use `table().container()` rather than just the table node for IE8 -
            // otherwise it only works once...
            $(dt.table().container()).on(
                'mousedown.rowReorder touchstart.rowReorder',
                this.c.selector,
                function (e) {
                    if (!that.c.enable) {
                        return;
                    }

                    // Ignore excluded children of the selector
                    if ($(e.target).is(that.c.excludedChildren)) {
                        return true;
                    }

                    var tr = $(this).closest('tr');
                    var row = dt.row(tr);

                    // Double check that it is a DataTable row
                    if (row.any()) {
                        that._emitEvent('pre-row-reorder', {
                            node: row.node(),
                            index: row.index()
                        });

                        that._mouseDown(e, tr);
                        return false;
                    }
                }
            );

            dt.on('destroy.rowReorder', function () {
                $(dt.table().container()).off('.rowReorder');
                dt.off('.rowReorder');
            });

            this._keyup = this._keyup.bind(this);
        },

        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Private methods
         */

        /**
         * Cache the measurements that RowReorder needs in the mouse move handler
         * to attempt to speed things up, rather than reading from the DOM.
         *
         * @private
         */
        _cachePositions: function () {
            var dt = this.s.dt;

            // Frustratingly, if we add `position:relative` to the tbody, the
            // position is still relatively to the parent. So we need to adjust
            // for that
            var headerHeight = $(dt.table().node()).find('thead').outerHeight();

            // Need to pass the nodes through jQuery to get them in document order,
            // not what DataTables thinks it is, since we have been altering the
            // order
            var nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());
            var middles = $.map(nodes, function (node, i) {
                var top = $(node).position().top - headerHeight;

                return (top + top + $(node).outerHeight()) / 2;
            });

            this.s.middles = middles;
            this.s.bodyTop = $(dt.table().body()).offset().top;
            this.s.windowHeight = $(window).height();
            this.s.documentOuterHeight = $(document).outerHeight();
            this.s.bodyArea = this._calcBodyArea();
        },

        /**
         * Clone a row so it can be floated around the screen
         *
         * @param  {jQuery} target Node to be cloned
         * @private
         */
        _clone: function (target) {
            var dt = this.s.dt;
            var clone = $(dt.table().node().cloneNode(false))
                .addClass('dt-rowReorder-float')
                .append('<tbody/>')
                .append(target.clone(false));

            // Match the table and column widths - read all sizes before setting
            // to reduce reflows
            var tableWidth = target.outerWidth();
            var tableHeight = target.outerHeight();
            var scrollBody = $($(this.s.dt.table().node()).parent());
            var scrollWidth = scrollBody.width();
            var scrollLeft = scrollBody.scrollLeft();
            var sizes = target.children().map(function () {
                return $(this).width();
            });

            clone
                .width(tableWidth)
                .height(tableHeight)
                .find('tr')
                .children()
                .each(function (i) {
                    this.style.width = sizes[i] + 'px';
                });

            var cloneParent = $('<div>')
                .addClass('dt-rowReorder-float-parent')
                .width(scrollWidth)
                .append(clone)
                .appendTo('body')
                .scrollLeft(scrollLeft);

            // Insert into the document to have it floating around

            this.dom.clone = clone;
            this.dom.cloneParent = cloneParent;
            this.s.domCloneOuterHeight = clone.outerHeight();
        },

        /**
         * Update the cloned item's position in the document
         *
         * @param  {object} e Event giving the mouse's position
         * @private
         */
        _clonePosition: function (e) {
            var start = this.s.start;
            var topDiff = this._eventToPage(e, 'Y') - start.top;
            var leftDiff = this._eventToPage(e, 'X') - start.left;
            var snap = this.c.snapX;
            var left;
            var top = topDiff + start.offsetTop;

            if (snap === true) {
                left = start.offsetLeft;
            }
            else if (typeof snap === 'number') {
                left = start.offsetLeft + snap;
            }
            else {
                left = leftDiff + start.offsetLeft + this.dom.cloneParent.scrollLeft();
            }

            if (top < 0) {
                top = 0;
            }
            else if (top + this.s.domCloneOuterHeight > this.s.documentOuterHeight) {
                top = this.s.documentOuterHeight - this.s.domCloneOuterHeight;
            }

            this.dom.cloneParent.css({
                top: top,
                left: left
            });
        },

        /**
         * Emit an event on the DataTable for listeners
         *
         * @param  {string} name Event name
         * @param  {array} args Event arguments
         * @private
         */
        _emitEvent: function (name, args) {
            var ret;

            this.s.dt.iterator('table', function (ctx, i) {
                var innerRet = $(ctx.nTable).triggerHandler(name + '.dt', args);

                if (innerRet !== undefined) {
                    ret = innerRet;
                }
            });

            return ret;
        },

        /**
         * Get pageX/Y position from an event, regardless of if it is a mouse or
         * touch event.
         *
         * @param  {object} e Event
         * @param  {string} pos X or Y (must be a capital)
         * @private
         */
        _eventToPage: function (e, pos) {
            if (e.type.indexOf('touch') !== -1) {
                return e.originalEvent.touches[0]['page' + pos];
            }

            return e['page' + pos];
        },

        /**
         * Mouse down event handler. Read initial positions and add event handlers
         * for the move.
         *
         * @param  {object} e      Mouse event
         * @param  {jQuery} target TR element that is to be moved
         * @private
         */
        _mouseDown: function (e, target) {
            var that = this;
            var dt = this.s.dt;
            var start = this.s.start;
            var cancelable = this.c.cancelable;

            var offset = target.offset();
            start.top = this._eventToPage(e, 'Y');
            start.left = this._eventToPage(e, 'X');
            start.offsetTop = offset.top;
            start.offsetLeft = offset.left;
            start.nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());

            this._cachePositions();
            this._clone(target);
            this._clonePosition(e);

            var bodyY = this._eventToPage(e, 'Y') - this.s.bodyTop;
            start.rowIndex = this._calcRowIndexByPos(bodyY);

            this.dom.target = target;
            target.addClass('dt-rowReorder-moving');

            $(document)
                .on('mouseup.rowReorder touchend.rowReorder', function (e) {
                    that._mouseUp(e);
                })
                .on('mousemove.rowReorder touchmove.rowReorder', function (e) {
                    that._mouseMove(e);
                });

            // Check if window is x-scrolling - if not, disable it for the duration
            // of the drag
            if ($(window).width() === $(document).width()) {
                $(document.body).addClass('dt-rowReorder-noOverflow');
            }

            // Cache scrolling information so mouse move doesn't need to read.
            // This assumes that the window and DT scroller will not change size
            // during an row drag, which I think is a fair assumption
            var scrollWrapper = this.dom.dtScroll;
            this.s.scroll = {
                windowHeight: $(window).height(),
                windowWidth: $(window).width(),
                dtTop: scrollWrapper.length ? scrollWrapper.offset().top : null,
                dtLeft: scrollWrapper.length ? scrollWrapper.offset().left : null,
                dtHeight: scrollWrapper.length ? scrollWrapper.outerHeight() : null,
                dtWidth: scrollWrapper.length ? scrollWrapper.outerWidth() : null
            };

            // Add keyup handler if dragging is cancelable
            if (cancelable) {
                $(document).on('keyup', this._keyup);
            }
        },

        /**
         * Mouse move event handler - move the cloned row and shuffle the table's
         * rows if required.
         *
         * @param  {object} e Mouse event
         * @private
         */
        _mouseMove: function (e) {
            this._clonePosition(e);

            var start = this.s.start;
            var cancelable = this.c.cancelable;

            if (cancelable) {
                var bodyArea = this.s.bodyArea;
                var cloneArea = this._calcCloneParentArea();
                this.s.dropAllowed = this._rectanglesIntersect(bodyArea, cloneArea);

                this.s.dropAllowed
                    ? $(this.dom.cloneParent).removeClass('drop-not-allowed')
                    : $(this.dom.cloneParent).addClass('drop-not-allowed');
            }

            // Transform the mouse position into a position in the table's body
            var bodyY = this._eventToPage(e, 'Y') - this.s.bodyTop;
            var middles = this.s.middles;
            var insertPoint = null;

            // Determine where the row should be inserted based on the mouse
            // position
            for (var i = 0, ien = middles.length; i < ien; i++) {
                if (bodyY < middles[i]) {
                    insertPoint = i;
                    break;
                }
            }

            if (insertPoint === null) {
                insertPoint = middles.length;
            }

            if (cancelable) {
                if (!this.s.dropAllowed) {
                    // Move the row back to its original position becasuse the drop is not allowed
                    insertPoint =
                        start.rowIndex > this.s.lastInsert ? start.rowIndex + 1 : start.rowIndex;
                }

                this.dom.target.toggleClass('dt-rowReorder-moving', this.s.dropAllowed);
            }

            this._moveTargetIntoPosition(insertPoint);

            this._shiftScroll(e);
        },

        /**
         * Mouse up event handler - release the event handlers and perform the
         * table updates
         *
         * @param  {object} e Mouse event
         * @private
         */
        _mouseUp: function (e) {
            var that = this;
            var dt = this.s.dt;
            var i, ien;
            var dataSrc = this.c.dataSrc;
            var dropAllowed = this.s.dropAllowed;

            if (!dropAllowed) {
                that._cancel();
                return;
            }

            // Calculate the difference
            var startNodes = this.s.start.nodes;
            var endNodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());
            var idDiff = {};
            var fullDiff = [];
            var diffNodes = [];
            var getDataFn = this.s.getDataFn;
            var setDataFn = this.s.setDataFn;

            for (i = 0, ien = startNodes.length; i < ien; i++) {
                if (startNodes[i] !== endNodes[i]) {
                    var id = dt.row(endNodes[i]).id();
                    var endRowData = dt.row(endNodes[i]).data();
                    var startRowData = dt.row(startNodes[i]).data();

                    if (id) {
                        idDiff[id] = getDataFn(startRowData);
                    }

                    fullDiff.push({
                        node: endNodes[i],
                        oldData: getDataFn(endRowData),
                        newData: getDataFn(startRowData),
                        newPosition: i,
                        oldPosition: $.inArray(endNodes[i], startNodes)
                    });

                    diffNodes.push(endNodes[i]);
                }
            }

            // Create event args
            var eventArgs = [
                fullDiff,
                {
                    dataSrc: dataSrc,
                    nodes: diffNodes,
                    values: idDiff,
                    triggerRow: dt.row(this.dom.target),
                    originalEvent: e
                }
            ];

            // Emit event
            var eventResult = this._emitEvent('row-reorder', eventArgs);

            if (eventResult === false) {
                that._cancel();
                return;
            }

            // Remove cloned elements, handlers, etc
            this._cleanupDragging();

            var update = function () {
                if (that.c.update) {
                    for (i = 0, ien = fullDiff.length; i < ien; i++) {
                        var row = dt.row(fullDiff[i].node);
                        var rowData = row.data();

                        setDataFn(rowData, fullDiff[i].newData);

                        // Invalidate the cell that has the same data source as the dataSrc
                        dt.columns().every(function () {
                            if (this.dataSrc() === dataSrc) {
                                dt.cell(fullDiff[i].node, this.index()).invalidate('data');
                            }
                        });
                    }

                    // Trigger row reordered event
                    that._emitEvent('row-reordered', eventArgs);

                    dt.draw(false);
                }
            };

            // Editor interface
            if (this.c.editor) {
                // Disable user interaction while Editor is submitting
                this.c.enable = false;

                this.c.editor
                    .edit(diffNodes, false, $.extend({ submit: 'changed' }, this.c.formOptions))
                    .multiSet(dataSrc, idDiff)
                    .one('preSubmitCancelled.rowReorder', function () {
                        that.c.enable = true;
                        that.c.editor.off('.rowReorder');
                        dt.draw(false);
                    })
                    .one('submitUnsuccessful.rowReorder', function () {
                        dt.draw(false);
                    })
                    .one('submitSuccess.rowReorder', function () {
                        update();
                    })
                    .one('submitComplete', function () {
                        that.c.enable = true;
                        that.c.editor.off('.rowReorder');
                    })
                    .submit();
            }
            else {
                update();
            }
        },

        /**
         * Moves the current target into the given position within the table
         * and caches the new positions
         *
         * @param  {integer} insertPoint Position
         * @private
         */
        _moveTargetIntoPosition: function (insertPoint) {
            var dt = this.s.dt;

            // Perform the DOM shuffle if it has changed from last time
            if (this.s.lastInsert === null || this.s.lastInsert !== insertPoint) {
                var nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());
                var insertPlacement = '';

                if (insertPoint > this.s.lastInsert) {
                    this.dom.target.insertAfter(nodes[insertPoint - 1]);
                    insertPlacement = 'after';
                }
                else {
                    this.dom.target.insertBefore(nodes[insertPoint]);
                    insertPlacement = 'before';
                }

                this._cachePositions();

                this.s.lastInsert = insertPoint;

                this._emitEvent('row-reorder-changed', {
                    insertPlacement,
                    insertPoint,
                    row: dt.row(this.dom.target)
                });
            }
        },

        /**
         * Removes the cloned elements, event handlers, scrolling intervals, etc
         *
         * @private
         */
        _cleanupDragging: function () {
            var cancelable = this.c.cancelable;

            this.dom.clone.remove();
            this.dom.cloneParent.remove();
            this.dom.clone = null;
            this.dom.cloneParent = null;

            this.dom.target.removeClass('dt-rowReorder-moving');
            //this.dom.target = null;

            $(document).off('.rowReorder');
            $(document.body).removeClass('dt-rowReorder-noOverflow');

            clearInterval(this.s.scrollInterval);
            this.s.scrollInterval = null;

            if (cancelable) {
                $(document).off('keyup', this._keyup);
            }
        },

        /**
         * Move the window and DataTables scrolling during a drag to scroll new
         * content into view.
         *
         * This matches the `_shiftScroll` method used in AutoFill, but only
         * horizontal scrolling is considered here.
         *
         * @param  {object} e Mouse move event object
         * @private
         */
        _shiftScroll: function (e) {
            var that = this;
            var scroll = this.s.scroll;
            var runInterval = false;
            var scrollSpeed = 5;
            var buffer = 65;
            var windowY = e.pageY - document.body.scrollTop,
                windowVert,
                dtVert;

            // Window calculations - based on the mouse position in the window,
            // regardless of scrolling
            if (windowY < $(window).scrollTop() + buffer) {
                windowVert = scrollSpeed * -1;
            }
            else if (windowY > scroll.windowHeight + $(window).scrollTop() - buffer) {
                windowVert = scrollSpeed;
            }

            // DataTables scrolling calculations - based on the table's position in
            // the document and the mouse position on the page
            if (scroll.dtTop !== null && e.pageY < scroll.dtTop + buffer) {
                dtVert = scrollSpeed * -1;
            }
            else if (scroll.dtTop !== null && e.pageY > scroll.dtTop + scroll.dtHeight - buffer) {
                dtVert = scrollSpeed;
            }

            // This is where it gets interesting. We want to continue scrolling
            // without requiring a mouse move, so we need an interval to be
            // triggered. The interval should continue until it is no longer needed,
            // but it must also use the latest scroll commands (for example consider
            // that the mouse might move from scrolling up to scrolling left, all
            // with the same interval running. We use the `scroll` object to "pass"
            // this information to the interval. Can't use local variables as they
            // wouldn't be the ones that are used by an already existing interval!
            if (windowVert || dtVert) {
                scroll.windowVert = windowVert;
                scroll.dtVert = dtVert;
                runInterval = true;
            }
            else if (this.s.scrollInterval) {
                // Don't need to scroll - remove any existing timer
                clearInterval(this.s.scrollInterval);
                this.s.scrollInterval = null;
            }

            // If we need to run the interval to scroll and there is no existing
            // interval (if there is an existing one, it will continue to run)
            if (!this.s.scrollInterval && runInterval) {
                this.s.scrollInterval = setInterval(function () {
                    // Don't need to worry about setting scroll <0 or beyond the
                    // scroll bound as the browser will just reject that.
                    if (scroll.windowVert) {
                        var top = $(document).scrollTop();
                        $(document).scrollTop(top + scroll.windowVert);

                        if (top !== $(document).scrollTop()) {
                            var move = parseFloat(that.dom.cloneParent.css('top'));
                            that.dom.cloneParent.css('top', move + scroll.windowVert);
                        }
                    }

                    // DataTables scrolling
                    if (scroll.dtVert) {
                        var scroller = that.dom.dtScroll[0];

                        if (scroll.dtVert) {
                            scroller.scrollTop += scroll.dtVert;
                        }
                    }
                }, 20);
            }
        },

        /**
         * Calculates the current area of the table body and returns it as a rectangle
         *
         * @private
         */
        _calcBodyArea: function (e) {
            var dt = this.s.dt;
            var offset = $(dt.table().body()).offset();
            var area = {
                left: offset.left,
                top: offset.top,
                right: offset.left + $(dt.table().body()).width(),
                bottom: offset.top + $(dt.table().body()).height()
            };

            return area;
        },

        /**
         * Calculates the current area of the cloned parent element and returns it as a rectangle
         *
         * @private
         */
        _calcCloneParentArea: function (e) {
            var offset = $(this.dom.cloneParent).offset();
            var area = {
                left: offset.left,
                top: offset.top,
                right: offset.left + $(this.dom.cloneParent).width(),
                bottom: offset.top + $(this.dom.cloneParent).height()
            };

            return area;
        },

        /**
         * Returns whether the given reactangles intersect or not
         *
         * @private
         */
        _rectanglesIntersect: function (a, b) {
            var noOverlap =
                a.left >= b.right || b.left >= a.right || a.top >= b.bottom || b.top >= a.bottom;

            return !noOverlap;
        },

        /**
         * Calculates the index of the row which lays under the given Y position or
         * returns -1 if no such row
         *
         * @param  {integer} insertPoint Position
         * @private
         */
        _calcRowIndexByPos: function (bodyY) {
            // Determine where the row is located based on the mouse
            // position

            var dt = this.s.dt;
            var nodes = $.unique(dt.rows({ page: 'current' }).nodes().toArray());
            var rowIndex = -1;
            var headerHeight = $(dt.table().node()).find('thead').outerHeight();

            $.each(nodes, function (i, node) {
                var top = $(node).position().top - headerHeight;
                var bottom = top + $(node).outerHeight();

                if (bodyY >= top && bodyY <= bottom) {
                    rowIndex = i;
                }
            });

            return rowIndex;
        },

        /**
         * Handles key up events and cancels the dragging if ESC key is pressed
         *
         * @param  {object} e Mouse move event object
         * @private
         */
        _keyup: function (e) {
            var cancelable = this.c.cancelable;

            if (cancelable && e.which === 27) {
                // ESC key is up
                e.preventDefault();
                this._cancel();
            }
        },

        /**
         * Cancels the dragging, moves target back into its original position
         * and cleans up the dragging
         *
         * @param  {object} e Mouse move event object
         * @private
         */
        _cancel: function () {
            var start = this.s.start;
            var insertPoint = start.rowIndex > this.s.lastInsert ? start.rowIndex + 1 : start.rowIndex;

            this._moveTargetIntoPosition(insertPoint);

            this._cleanupDragging();

            // Emit event
            this._emitEvent('row-reorder-canceled', [this.s.start.rowIndex]);
        }
    });

    /**
     * RowReorder default settings for initialisation
     *
     * @namespace
     * @name RowReorder.defaults
     * @static
     */
    RowReorder.defaults = {
        /**
         * Data point in the host row's data source object for where to get and set
         * the data to reorder. This will normally also be the sorting column.
         *
         * @type {Number}
         */
        dataSrc: 0,

        /**
         * Editor instance that will be used to perform the update
         *
         * @type {DataTable.Editor}
         */
        editor: null,

        /**
         * Enable / disable RowReorder's user interaction
         * @type {Boolean}
         */
        enable: true,

        /**
         * Form options to pass to Editor when submitting a change in the row order.
         * See the Editor `from-options` object for details of the options
         * available.
         * @type {Object}
         */
        formOptions: {},

        /**
         * Drag handle selector. This defines the element that when dragged will
         * reorder a row.
         *
         * @type {String}
         */
        selector: 'td:first-child',

        /**
         * Optionally lock the dragged row's x-position. This can be `true` to
         * fix the position match the host table's, `false` to allow free movement
         * of the row, or a number to define an offset from the host table.
         *
         * @type {Boolean|number}
         */
        snapX: false,

        /**
         * Update the table's data on drop
         *
         * @type {Boolean}
         */
        update: true,

        /**
         * Selector for children of the drag handle selector that mouseDown events
         * will be passed through to and drag will not activate
         *
         * @type {String}
         */
        excludedChildren: 'a',

        /**
         * Enable / disable the canceling of the drag & drop interaction
         *
         * @type {Boolean}
         */
        cancelable: false
    };

    /*
     * API
     */
    var Api = $.fn.dataTable.Api;

    // Doesn't do anything - work around for a bug in DT... Not documented
    Api.register('rowReorder()', function () {
        return this;
    });

    Api.register('rowReorder.enable()', function (toggle) {
        if (toggle === undefined) {
            toggle = true;
        }

        return this.iterator('table', function (ctx) {
            if (ctx.rowreorder) {
                ctx.rowreorder.c.enable = toggle;
            }
        });
    });

    Api.register('rowReorder.disable()', function () {
        return this.iterator('table', function (ctx) {
            if (ctx.rowreorder) {
                ctx.rowreorder.c.enable = false;
            }
        });
    });

    /**
     * Version information
     *
     * @name RowReorder.version
     * @static
     */
    RowReorder.version = '1.5.0';

    $.fn.dataTable.RowReorder = RowReorder;
    $.fn.DataTable.RowReorder = RowReorder;

    // Attach a listener to the document which listens for DataTables initialisation
    // events so we can automatically initialise
    $(document).on('init.dt.dtr', function (e, settings, json) {
        if (e.namespace !== 'dt') {
            return;
        }

        var init = settings.oInit.rowReorder;
        var defaults = DataTable.defaults.rowReorder;

        if (init || defaults) {
            var opts = $.extend({}, init, defaults);

            if (init !== false) {
                new RowReorder(settings, opts);
            }
        }
    });


    return DataTable;
}));
/*! DataTables styling wrapper for RowReorder
 * © SpryMedia Ltd - datatables.net/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net-dt', 'datatables.net-rowreorder'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        var jq = require('jquery');
        var cjsRequires = function (root, $) {
            if (!$.fn.dataTable) {
                require('datatables.net-dt')(root, $);
            }

            if (!$.fn.dataTable.RowReorder) {
                require('datatables.net-rowreorder')(root, $);
            }
        };

        if (typeof window === 'undefined') {
            module.exports = function (root, $) {
                if (!root) {
                    // CommonJS environments without a window global must pass a
                    // root. This will give an error otherwise
                    root = window;
                }

                if (!$) {
                    $ = jq(root);
                }

                cjsRequires(root, $);
                return factory($, root, root.document);
            };
        }
        else {
            cjsRequires(window, jq);
            module.exports = factory(jq, window, window.document);
        }
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;




    return DataTable;
}));
/*! Buttons for DataTables 3.1.0
 * © SpryMedia Ltd - datatables.net/license
 */
!function (e) { var o, i; "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function (t) { return e(t, window, document) }) : "object" == typeof exports ? (o = require("jquery"), i = function (t, n) { n.fn.dataTable || require("datatables.net")(t, n) }, "undefined" == typeof window ? module.exports = function (t, n) { return t = t || window, n = n || o(t), i(t, n), e(n, t, t.document) } : (i(window, o), module.exports = e(o, window, window.document))) : e(jQuery, window, document) }(function (x, g, m) { "use strict"; var e = x.fn.dataTable, o = 0, C = 0, w = e.ext.buttons, i = null; function v(t, n, e) { x.fn.animate ? t.stop().fadeIn(n, e) : (t.css("display", "block"), e && e.call(t)) } function y(t, n, e) { x.fn.animate ? t.stop().fadeOut(n, e) : (t.css("display", "none"), e && e.call(t)) } function _(n, t) { if (!e.versionCheck("2")) throw "Warning: Buttons requires DataTables 2 or newer"; if (!(this instanceof _)) return function (t) { return new _(t, n).container() }; !0 === (t = void 0 === t ? {} : t) && (t = {}), Array.isArray(t) && (t = { buttons: t }), this.c = x.extend(!0, {}, _.defaults, t), t.buttons && (this.c.buttons = t.buttons), this.s = { dt: new e.Api(n), buttons: [], listenKeys: "", namespace: "dtb" + o++ }, this.dom = { container: x("<" + this.c.dom.container.tag + "/>").addClass(this.c.dom.container.className) }, this._constructor() } x.extend(_.prototype, { action: function (t, n) { t = this._nodeToButton(t); return void 0 === n ? t.conf.action : (t.conf.action = n, this) }, active: function (t, n) { var t = this._nodeToButton(t), e = this.c.dom.button.active, o = x(t.node); return t.inCollection && this.c.dom.collection.button && void 0 !== this.c.dom.collection.button.active && (e = this.c.dom.collection.button.active), void 0 === n ? o.hasClass(e) : (o.toggleClass(e, void 0 === n || n), this) }, add: function (t, n, e) { var o = this.s.buttons; if ("string" == typeof n) { for (var i = n.split("-"), s = this.s, r = 0, a = i.length - 1; r < a; r++)s = s.buttons[+i[r]]; o = s.buttons, n = +i[i.length - 1] } return this._expandButton(o, t, void 0 !== t ? t.split : void 0, (void 0 === t || void 0 === t.split || 0 === t.split.length) && void 0 !== s, !1, n), void 0 !== e && !0 !== e || this._draw(), this }, collectionRebuild: function (t, n) { var e = this._nodeToButton(t); if (void 0 !== n) { for (var o = e.buttons.length - 1; 0 <= o; o--)this.remove(e.buttons[o].node); for (e.conf.prefixButtons && n.unshift.apply(n, e.conf.prefixButtons), e.conf.postfixButtons && n.push.apply(n, e.conf.postfixButtons), o = 0; o < n.length; o++) { var i = n[o]; this._expandButton(e.buttons, i, void 0 !== i && void 0 !== i.config && void 0 !== i.config.split, !0, void 0 !== i.parentConf && void 0 !== i.parentConf.split, null, i.parentConf) } } this._draw(e.collection, e.buttons) }, container: function () { return this.dom.container }, disable: function (t) { t = this._nodeToButton(t); return x(t.node).addClass(this.c.dom.button.disabled).prop("disabled", !0), this }, destroy: function () { x("body").off("keyup." + this.s.namespace); for (var t = this.s.buttons.slice(), n = 0, e = t.length; n < e; n++)this.remove(t[n].node); this.dom.container.remove(); var o = this.s.dt.settings()[0]; for (n = 0, e = o.length; n < e; n++)if (o.inst === this) { o.splice(n, 1); break } return this }, enable: function (t, n) { return !1 === n ? this.disable(t) : (n = this._nodeToButton(t), x(n.node).removeClass(this.c.dom.button.disabled).prop("disabled", !1), this) }, index: function (t, n, e) { n || (n = "", e = this.s.buttons); for (var o = 0, i = e.length; o < i; o++) { var s = e[o].buttons; if (e[o].node === t) return n + o; if (s && s.length) { s = this.index(t, o + "-", s); if (null !== s) return s } } return null }, name: function () { return this.c.name }, node: function (t) { return t ? (t = this._nodeToButton(t), x(t.node)) : this.dom.container }, processing: function (t, n) { var e = this.s.dt, o = this._nodeToButton(t); return void 0 === n ? x(o.node).hasClass("processing") : (x(o.node).toggleClass("processing", n), x(e.table().node()).triggerHandler("buttons-processing.dt", [n, e.button(t), e, x(t), o.conf]), this) }, remove: function (t) { var n = this._nodeToButton(t), e = this._nodeToHost(t), o = this.s.dt; if (n.buttons.length) for (var i = n.buttons.length - 1; 0 <= i; i--)this.remove(n.buttons[i].node); n.conf.destroying = !0, n.conf.destroy && n.conf.destroy.call(o.button(t), o, x(t), n.conf), this._removeKey(n.conf), x(n.node).remove(); o = x.inArray(n, e); return e.splice(o, 1), this }, text: function (t, n) { function e(t) { return "function" == typeof t ? t(i, s, o.conf) : t } var o = this._nodeToButton(t), t = o.textNode, i = this.s.dt, s = x(o.node); return void 0 === n ? e(o.conf.text) : (o.conf.text = n, t.html(e(n)), this) }, _constructor: function () { var e = this, t = this.s.dt, o = t.settings()[0], n = this.c.buttons; o._buttons || (o._buttons = []), o._buttons.push({ inst: this, name: this.c.name }); for (var i = 0, s = n.length; i < s; i++)this.add(n[i]); t.on("destroy", function (t, n) { n === o && e.destroy() }), x("body").on("keyup." + this.s.namespace, function (t) { var n; m.activeElement && m.activeElement !== m.body || (n = String.fromCharCode(t.keyCode).toLowerCase(), -1 !== e.s.listenKeys.toLowerCase().indexOf(n) && e._keypress(n, t)) }) }, _addKey: function (t) { t.key && (this.s.listenKeys += (x.isPlainObject(t.key) ? t.key : t).key) }, _draw: function (t, n) { t || (t = this.dom.container, n = this.s.buttons), t.children().detach(); for (var e = 0, o = n.length; e < o; e++)t.append(n[e].inserter), t.append(" "), n[e].buttons && n[e].buttons.length && this._draw(n[e].collection, n[e].buttons) }, _expandButton: function (t, n, e, o, i, s, r) { for (var a, l = this.s.dt, c = this.c.dom.collection, u = Array.isArray(n) ? n : [n], d = 0, f = (u = void 0 === n ? Array.isArray(e) ? e : [e] : u).length; d < f; d++) { var p = this._resolveExtends(u[d]); if (p) if (a = !(!p.config || !p.config.split), Array.isArray(p)) this._expandButton(t, p, void 0 !== h && void 0 !== h.conf ? h.conf.split : void 0, o, void 0 !== r && void 0 !== r.split, s, r); else { var h = this._buildButton(p, o, void 0 !== p.split || void 0 !== p.config && void 0 !== p.config.split, i); if (h) { if (null != s ? (t.splice(s, 0, h), s++) : t.push(h), h.conf.buttons && (h.collection = x("<" + c.container.content.tag + "/>"), h.conf._collection = h.collection, x(h.node).append(c.action.dropHtml), this._expandButton(h.buttons, h.conf.buttons, h.conf.split, !a, a, s, h.conf)), h.conf.split) { h.collection = x("<" + c.container.tag + "/>"), h.conf._collection = h.collection; for (var b = 0; b < h.conf.split.length; b++) { var g = h.conf.split[b]; "object" == typeof g && (g.parent = r, void 0 === g.collectionLayout && (g.collectionLayout = h.conf.collectionLayout), void 0 === g.dropup && (g.dropup = h.conf.dropup), void 0 === g.fade) && (g.fade = h.conf.fade) } this._expandButton(h.buttons, h.conf.buttons, h.conf.split, !a, a, s, h.conf) } h.conf.parent = r, p.init && p.init.call(l.button(h.node), l, x(h.node), p) } } } }, _buildButton: function (n, t, e, o) { function i(t) { return "function" == typeof t ? t(f, c, n) : t } var s, r, a, l, c, u = this, d = this.c.dom, f = this.s.dt, p = x.extend(!0, {}, d.button); if (t && e && d.collection.split ? x.extend(!0, p, d.collection.split.action) : o || t ? x.extend(!0, p, d.collection.button) : e && x.extend(!0, p, d.split.button), n.spacer) return d = x("<" + p.spacer.tag + "/>").addClass("dt-button-spacer " + n.style + " " + p.spacer.className).html(i(n.text)), { conf: n, node: d, inserter: d, buttons: [], inCollection: t, isSplit: e, collection: null, textNode: d }; if (n.available && !n.available(f, n) && !n.html) return !1; n.html ? c = x(n.html) : (r = function (t, n, e, o, i) { o.action.call(n.button(e), t, n, e, o, i), x(n.table().node()).triggerHandler("buttons-action.dt", [n.button(e), n, e, o]) }, a = function (t, n, e, o) { o.async ? (u.processing(e[0], !0), setTimeout(function () { r(t, n, e, o, function () { u.processing(e[0], !1) }) }, o.async)) : r(t, n, e, o, function () { }) }, d = n.tag || p.tag, l = void 0 === n.clickBlurs || n.clickBlurs, c = x("<" + d + "/>").addClass(p.className).attr("tabindex", this.s.dt.settings()[0].iTabIndex).attr("aria-controls", this.s.dt.table().node().id).on("click.dtb", function (t) { t.preventDefault(), !c.hasClass(p.disabled) && n.action && a(t, f, c, n), l && c.trigger("blur") }).on("keypress.dtb", function (t) { 13 === t.keyCode && (t.preventDefault(), !c.hasClass(p.disabled)) && n.action && a(t, f, c, n) }), "a" === d.toLowerCase() && c.attr("href", "#"), "button" === d.toLowerCase() && c.attr("type", "button"), s = p.liner.tag ? (d = x("<" + p.liner.tag + "/>").html(i(n.text)).addClass(p.liner.className), "a" === p.liner.tag.toLowerCase() && d.attr("href", "#"), c.append(d), d) : (c.html(i(n.text)), c), !1 === n.enabled && c.addClass(p.disabled), n.className && c.addClass(n.className), n.titleAttr && c.attr("title", i(n.titleAttr)), n.attr && c.attr(n.attr), n.namespace || (n.namespace = ".dt-button-" + C++), void 0 !== n.config && n.config.split && (n.split = n.config.split)); var h, b, g, m, v, y, d = this.c.dom.buttonContainer, d = d && d.tag ? x("<" + d.tag + "/>").addClass(d.className).append(c) : c; return this._addKey(n), this.c.buttonCreated && (d = this.c.buttonCreated(n, d)), e && (b = (h = t ? x.extend(!0, this.c.dom.split, this.c.dom.collection.split) : this.c.dom.split).wrapper, g = x("<" + b.tag + "/>").addClass(b.className).append(c), m = x.extend(n, { align: h.dropdown.align, attr: { "aria-haspopup": "dialog", "aria-expanded": !1 }, className: h.dropdown.className, closeButton: !1, splitAlignClass: h.dropdown.splitAlignClass, text: h.dropdown.text }), this._addKey(m), v = function (t, n, e, o) { w.split.action.call(n.button(g), t, n, e, o), x(n.table().node()).triggerHandler("buttons-action.dt", [n.button(e), n, e, o]), e.attr("aria-expanded", !0) }, y = x('<button class="' + h.dropdown.className + ' dt-button"></button>').html(h.dropdown.dropHtml).on("click.dtb", function (t) { t.preventDefault(), t.stopPropagation(), y.hasClass(p.disabled) || v(t, f, y, m), l && y.trigger("blur") }).on("keypress.dtb", function (t) { 13 === t.keyCode && (t.preventDefault(), y.hasClass(p.disabled) || v(t, f, y, m)) }), 0 === n.split.length && y.addClass("dtb-hide-drop"), g.append(y).attr(m.attr)), { conf: n, node: (e ? g : c).get(0), inserter: e ? g : d, buttons: [], inCollection: t, isSplit: e, inSplit: o, collection: null, textNode: s } }, _nodeToButton: function (t, n) { for (var e = 0, o = (n = n || this.s.buttons).length; e < o; e++) { if (n[e].node === t) return n[e]; if (n[e].buttons.length) { var i = this._nodeToButton(t, n[e].buttons); if (i) return i } } }, _nodeToHost: function (t, n) { for (var e = 0, o = (n = n || this.s.buttons).length; e < o; e++) { if (n[e].node === t) return n; if (n[e].buttons.length) { var i = this._nodeToHost(t, n[e].buttons); if (i) return i } } }, _keypress: function (s, r) { var a; r._buttonsHandled || (a = function (t) { for (var n, e, o = 0, i = t.length; o < i; o++)n = t[o].conf, e = t[o].node, !n.key || n.key !== s && (!x.isPlainObject(n.key) || n.key.key !== s || n.key.shiftKey && !r.shiftKey || n.key.altKey && !r.altKey || n.key.ctrlKey && !r.ctrlKey || n.key.metaKey && !r.metaKey) || (r._buttonsHandled = !0, x(e).click()), t[o].buttons.length && a(t[o].buttons) })(this.s.buttons) }, _removeKey: function (t) { var n; t.key && (t = (x.isPlainObject(t.key) ? t.key : t).key, n = this.s.listenKeys.split(""), t = x.inArray(t, n), n.splice(t, 1), this.s.listenKeys = n.join("")) }, _resolveExtends: function (e) { function t(t) { for (var n = 0; !x.isPlainObject(t) && !Array.isArray(t);) { if (void 0 === t) return; if ("function" == typeof t) { if (!(t = t.call(i, s, e))) return !1 } else if ("string" == typeof t) { if (!w[t]) return { html: t }; t = w[t] } if (30 < ++n) throw "Buttons: Too many iterations" } return Array.isArray(t) ? t : x.extend({}, t) } var n, o, i = this, s = this.s.dt; for (e = t(e); e && e.extend;) { if (!w[e.extend]) throw "Cannot extend unknown button type: " + e.extend; var r = t(w[e.extend]); if (Array.isArray(r)) return r; if (!r) return !1; var a = r.className; void 0 !== e.config && void 0 !== r.config && (e.config = x.extend({}, r.config, e.config)), e = x.extend({}, r, e), a && e.className !== a && (e.className = a + " " + e.className), e.extend = r.extend } var l = e.postfixButtons; if (l) for (e.buttons || (e.buttons = []), n = 0, o = l.length; n < o; n++)e.buttons.push(l[n]); var c = e.prefixButtons; if (c) for (e.buttons || (e.buttons = []), n = 0, o = c.length; n < o; n++)e.buttons.splice(n, 0, c[n]); return e }, _popover: function (o, t, n) { function i() { f = !0, y(x(h), p.fade, function () { x(this).detach() }), x(u.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes()).attr("aria-expanded", "false"), x("div.dt-button-background").off("click.dtb-collection"), _.background(!1, p.backgroundClassName, p.fade, b), x(g).off("resize.resize.dtb-collection"), x("body").off(".dtb-collection"), u.off("buttons-action.b-internal"), u.off("destroy") } var e, s, r, a, l, c, u = t, d = this.c, f = !1, p = x.extend({ align: "button-left", autoClose: !1, background: !0, backgroundClassName: "dt-button-background", closeButton: !0, containerClassName: d.dom.collection.container.className, contentClassName: d.dom.collection.container.content.className, collectionLayout: "", collectionTitle: "", dropup: !1, fade: 400, popoverTitle: "", rightAlignClassName: "dt-button-right", tag: d.dom.collection.container.tag }, n), h = p.tag + "." + p.containerClassName.replace(/ /g, "."), b = t.node(); !1 === o ? i() : ((d = x(u.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes())).length && (b.closest(h).length && (b = d.eq(0)), i()), n = x(".dt-button", o).length, d = "", 3 === n ? d = "dtb-b3" : 2 === n ? d = "dtb-b2" : 1 === n && (d = "dtb-b1"), e = x("<" + p.tag + "/>").addClass(p.containerClassName).addClass(p.collectionLayout).addClass(p.splitAlignClass).addClass(d).css("display", "none").attr({ "aria-modal": !0, role: "dialog" }), o = x(o).addClass(p.contentClassName).attr("role", "menu").appendTo(e), b.attr("aria-expanded", "true"), b.parents("body")[0] !== m.body && (b = m.body.lastChild), p.popoverTitle ? e.prepend('<div class="dt-button-collection-title">' + p.popoverTitle + "</div>") : p.collectionTitle && e.prepend('<div class="dt-button-collection-title">' + p.collectionTitle + "</div>"), p.closeButton && e.prepend('<div class="dtb-popover-close">&times;</div>').addClass("dtb-collection-closeable"), v(e.insertAfter(b), p.fade), n = x(t.table().container()), d = e.css("position"), "container" !== p.span && "dt-container" !== p.align || (b = b.parent(), e.css("width", n.width())), "absolute" === d ? (t = x(b[0].offsetParent), n = b.position(), d = b.offset(), a = t.offset(), s = t.position(), r = g.getComputedStyle(t[0]), a.height = t.outerHeight(), a.width = t.width() + parseFloat(r.paddingLeft), a.right = a.left + a.width, a.bottom = a.top + a.height, t = n.top + b.outerHeight(), a = n.left, e.css({ top: t, left: a }), r = g.getComputedStyle(e[0]), (l = e.offset()).height = e.outerHeight(), l.width = e.outerWidth(), l.right = l.left + l.width, l.bottom = l.top + l.height, l.marginTop = parseFloat(r.marginTop), l.marginBottom = parseFloat(r.marginBottom), p.dropup && (t = n.top - l.height - l.marginTop - l.marginBottom), "button-right" !== p.align && !e.hasClass(p.rightAlignClassName) || (a = n.left - l.width + b.outerWidth()), "dt-container" !== p.align && "container" !== p.align || a < n.left && (a = -n.left), s.left + a + l.width > x(g).width() && (a = x(g).width() - l.width - s.left), d.left + a < 0 && (a = -d.left), s.top + t + l.height > x(g).height() + x(g).scrollTop() && (t = n.top - l.height - l.marginTop - l.marginBottom), s.top + t < x(g).scrollTop() && (t = n.top + b.outerHeight()), e.css({ top: t, left: a })) : ((c = function () { var t = x(g).height() / 2, n = e.height() / 2; e.css("marginTop", -1 * (n = t < n ? t : n)) })(), x(g).on("resize.dtb-collection", function () { c() })), p.background && _.background(!0, p.backgroundClassName, p.fade, p.backgroundHost || b), x("div.dt-button-background").on("click.dtb-collection", function () { }), p.autoClose && setTimeout(function () { u.on("buttons-action.b-internal", function (t, n, e, o) { o[0] !== b[0] && i() }) }, 0), x(e).trigger("buttons-popover.dt"), u.on("destroy", i), setTimeout(function () { f = !1, x("body").on("click.dtb-collection", function (t) { var n, e; !f && (n = x.fn.addBack ? "addBack" : "andSelf", e = x(t.target).parent()[0], !x(t.target).parents()[n]().filter(o).length && !x(e).hasClass("dt-buttons") || x(t.target).hasClass("dt-button-background")) && i() }).on("keyup.dtb-collection", function (t) { 27 === t.keyCode && i() }).on("keydown.dtb-collection", function (t) { var n = x("a, button", o), e = m.activeElement; 9 === t.keyCode && (-1 === n.index(e) ? (n.first().focus(), t.preventDefault()) : t.shiftKey ? e === n[0] && (n.last().focus(), t.preventDefault()) : e === n.last()[0] && (n.first().focus(), t.preventDefault())) }) }, 0)) } }), _.background = function (t, n, e, o) { void 0 === e && (e = 400), o = o || m.body, t ? v(x("<div/>").addClass(n).css("display", "none").insertAfter(o), e) : y(x("div." + n), e, function () { x(this).removeClass(n).remove() }) }, _.instanceSelector = function (t, s) { var r, a, l; return null == t ? x.map(s, function (t) { return t.inst }) : (r = [], a = x.map(s, function (t) { return t.name }), (l = function (t) { var n; if (Array.isArray(t)) for (var e = 0, o = t.length; e < o; e++)l(t[e]); else if ("string" == typeof t) -1 !== t.indexOf(",") ? l(t.split(",")) : -1 !== (n = x.inArray(t.trim(), a)) && r.push(s[n].inst); else if ("number" == typeof t) r.push(s[t].inst); else if ("object" == typeof t && t.nodeName) for (var i = 0; i < s.length; i++)s[i].inst.dom.container[0] === t && r.push(s[i].inst); else "object" == typeof t && r.push(t) })(t), r) }, _.buttonSelector = function (t, n) { for (var c = [], u = function (t, n, e) { for (var o, i, s = 0, r = n.length; s < r; s++)(o = n[s]) && (t.push({ node: o.node, name: o.conf.name, idx: i = void 0 !== e ? e + s : s + "" }), o.buttons) && u(t, o.buttons, i + "-") }, d = function (t, n) { var e = [], o = (u(e, n.s.buttons), x.map(e, function (t) { return t.node })); if (Array.isArray(t) || t instanceof x) for (s = 0, r = t.length; s < r; s++)d(t[s], n); else if (null == t || "*" === t) for (s = 0, r = e.length; s < r; s++)c.push({ inst: n, node: e[s].node }); else if ("number" == typeof t) n.s.buttons[t] && c.push({ inst: n, node: n.s.buttons[t].node }); else if ("string" == typeof t) if (-1 !== t.indexOf(",")) for (var i = t.split(","), s = 0, r = i.length; s < r; s++)d(i[s].trim(), n); else if (t.match(/^\d+(\-\d+)*$/)) { var a = x.map(e, function (t) { return t.idx }); c.push({ inst: n, node: e[x.inArray(t, a)].node }) } else if (-1 !== t.indexOf(":name")) { var l = t.replace(":name", ""); for (s = 0, r = e.length; s < r; s++)e[s].name === l && c.push({ inst: n, node: e[s].node }) } else x(o).filter(t).each(function () { c.push({ inst: n, node: this }) }); else "object" == typeof t && t.nodeName && -1 !== (a = x.inArray(t, o)) && c.push({ inst: n, node: o[a] }) }, e = 0, o = t.length; e < o; e++) { var i = t[e]; d(n, i) } return c }, _.stripData = function (t, n) { return t = "string" == typeof t && (t = _.stripHtmlScript(t), t = _.stripHtmlComments(t), n && !n.stripHtml || (t = e.util.stripHtml(t)), n && !n.trim || (t = t.trim()), n && !n.stripNewlines || (t = t.replace(/\n/g, " ")), !n || n.decodeEntities) ? i ? i(t) : (c.innerHTML = t, c.value) : t }, _.entityDecoder = function (t) { i = t }, _.stripHtmlComments = function (t) { for (var n; (t = (n = t).replace(/(<!--.*?--!?>)|(<!--[\S\s]+?--!?>)|(<!--[\S\s]*?$)/g, "")) !== n;); return t }, _.stripHtmlScript = function (t) { for (var n; (t = (n = t).replace(/<script\b[^<]*(?:(?!<\/script[^>]*>)<[^<]*)*<\/script[^>]*>/gi, "")) !== n;); return t }, _.defaults = { buttons: ["copy", "excel", "csv", "pdf", "print"], name: "main", tabIndex: 0, dom: { container: { tag: "div", className: "dt-buttons" }, collection: { action: { dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>' }, container: { className: "dt-button-collection", content: { className: "", tag: "div" }, tag: "div" } }, button: { tag: "button", className: "dt-button", active: "dt-button-active", disabled: "disabled", spacer: { className: "dt-button-spacer", tag: "span" }, liner: { tag: "span", className: "" } }, split: { action: { className: "dt-button-split-drop-button dt-button", tag: "button" }, dropdown: { align: "split-right", className: "dt-button-split-drop", dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>', splitAlignClass: "dt-button-split-left", tag: "button" }, wrapper: { className: "dt-button-split", tag: "div" } } } }, x.extend(w, { collection: { text: function (t) { return t.i18n("buttons.collection", "Collection") }, className: "buttons-collection", closeButton: !(_.version = "3.1.0"), init: function (t, n) { n.attr("aria-expanded", !1) }, action: function (t, n, e, o) { o._collection.parents("body").length ? this.popover(!1, o) : this.popover(o._collection, o), "keypress" === t.type && x("a, button", o._collection).eq(0).focus() }, attr: { "aria-haspopup": "dialog" } }, split: { text: function (t) { return t.i18n("buttons.split", "Split") }, className: "buttons-split", closeButton: !1, init: function (t, n) { return n.attr("aria-expanded", !1) }, action: function (t, n, e, o) { this.popover(o._collection, o) }, attr: { "aria-haspopup": "dialog" } }, copy: function () { if (w.copyHtml5) return "copyHtml5" }, csv: function (t, n) { if (w.csvHtml5 && w.csvHtml5.available(t, n)) return "csvHtml5" }, excel: function (t, n) { if (w.excelHtml5 && w.excelHtml5.available(t, n)) return "excelHtml5" }, pdf: function (t, n) { if (w.pdfHtml5 && w.pdfHtml5.available(t, n)) return "pdfHtml5" }, pageLength: function (t) { var n = t.settings()[0].aLengthMenu, e = [], o = []; if (Array.isArray(n[0])) e = n[0], o = n[1]; else for (var i = 0; i < n.length; i++) { var s = n[i]; x.isPlainObject(s) ? (e.push(s.value), o.push(s.label)) : (e.push(s), o.push(s)) } return { extend: "collection", text: function (t) { return t.i18n("buttons.pageLength", { "-1": "Show all rows", _: "Show %d rows" }, t.page.len()) }, className: "buttons-page-length", autoClose: !0, buttons: x.map(e, function (s, t) { return { text: o[t], className: "button-page-length", action: function (t, n) { n.page.len(s).draw() }, init: function (t, n, e) { function o() { i.active(t.page.len() === s) } var i = this; t.on("length.dt" + e.namespace, o), o() }, destroy: function (t, n, e) { t.off("length.dt" + e.namespace) } } }), init: function (t, n, e) { var o = this; t.on("length.dt" + e.namespace, function () { o.text(e.text) }) }, destroy: function (t, n, e) { t.off("length.dt" + e.namespace) } } }, spacer: { style: "empty", spacer: !0, text: function (t) { return t.i18n("buttons.spacer", "") } } }), e.Api.register("buttons()", function (n, e) { void 0 === e && (e = n, n = void 0), this.selector.buttonGroup = n; var t = this.iterator(!0, "table", function (t) { if (t._buttons) return _.buttonSelector(_.instanceSelector(n, t._buttons), e) }, !0); return t._groupSelector = n, t }), e.Api.register("button()", function (t, n) { t = this.buttons(t, n); return 1 < t.length && t.splice(1, t.length), t }), e.Api.registerPlural("buttons().active()", "button().active()", function (n) { return void 0 === n ? this.map(function (t) { return t.inst.active(t.node) }) : this.each(function (t) { t.inst.active(t.node, n) }) }), e.Api.registerPlural("buttons().action()", "button().action()", function (n) { return void 0 === n ? this.map(function (t) { return t.inst.action(t.node) }) : this.each(function (t) { t.inst.action(t.node, n) }) }), e.Api.registerPlural("buttons().collectionRebuild()", "button().collectionRebuild()", function (e) { return this.each(function (t) { for (var n = 0; n < e.length; n++)"object" == typeof e[n] && (e[n].parentConf = t); t.inst.collectionRebuild(t.node, e) }) }), e.Api.register(["buttons().enable()", "button().enable()"], function (n) { return this.each(function (t) { t.inst.enable(t.node, n) }) }), e.Api.register(["buttons().disable()", "button().disable()"], function () { return this.each(function (t) { t.inst.disable(t.node) }) }), e.Api.register("button().index()", function () { var n = null; return this.each(function (t) { t = t.inst.index(t.node); null !== t && (n = t) }), n }), e.Api.registerPlural("buttons().nodes()", "button().node()", function () { var n = x(); return x(this.each(function (t) { n = n.add(t.inst.node(t.node)) })), n }), e.Api.registerPlural("buttons().processing()", "button().processing()", function (n) { return void 0 === n ? this.map(function (t) { return t.inst.processing(t.node) }) : this.each(function (t) { t.inst.processing(t.node, n) }) }), e.Api.registerPlural("buttons().text()", "button().text()", function (n) { return void 0 === n ? this.map(function (t) { return t.inst.text(t.node) }) : this.each(function (t) { t.inst.text(t.node, n) }) }), e.Api.registerPlural("buttons().trigger()", "button().trigger()", function () { return this.each(function (t) { t.inst.node(t.node).trigger("click") }) }), e.Api.register("button().popover()", function (n, e) { return this.map(function (t) { return t.inst._popover(n, this.button(this[0].node), e) }) }), e.Api.register("buttons().containers()", function () { var i = x(), s = this._groupSelector; return this.iterator(!0, "table", function (t) { if (t._buttons) for (var n = _.instanceSelector(s, t._buttons), e = 0, o = n.length; e < o; e++)i = i.add(n[e].container()) }), i }), e.Api.register("buttons().container()", function () { return this.containers().eq(0) }), e.Api.register("button().add()", function (t, n, e) { var o = this.context; return o.length && (o = _.instanceSelector(this._groupSelector, o[0]._buttons)).length && o[0].add(n, t, e), this.button(this._groupSelector, t) }), e.Api.register("buttons().destroy()", function () { return this.pluck("inst").unique().each(function (t) { t.destroy() }), this }), e.Api.registerPlural("buttons().remove()", "buttons().remove()", function () { return this.each(function (t) { t.inst.remove(t.node) }), this }), e.Api.register("buttons.info()", function (t, n, e) { var o = this; return !1 === t ? (this.off("destroy.btn-info"), y(x("#datatables_buttons_info"), 400, function () { x(this).remove() }), clearTimeout(s), s = null) : (s && clearTimeout(s), x("#datatables_buttons_info").length && x("#datatables_buttons_info").remove(), t = t ? "<h2>" + t + "</h2>" : "", v(x('<div id="datatables_buttons_info" class="dt-button-info"/>').html(t).append(x("<div/>")["string" == typeof n ? "html" : "append"](n)).css("display", "none").appendTo("body")), void 0 !== e && 0 !== e && (s = setTimeout(function () { o.buttons.info(!1) }, e)), this.on("destroy.btn-info", function () { o.buttons.info(!1) })), this }), e.Api.register("buttons.exportData()", function (t) { if (this.context.length) return u(new e.Api(this.context[0]), t) }), e.Api.register("buttons.exportInfo()", function (t) { return { filename: n(t = t || {}, this), title: a(t, this), messageTop: l(this, t, t.message || t.messageTop, "top"), messageBottom: l(this, t, t.messageBottom, "bottom") } }); var s, n = function (t, n) { var e; return null == (e = "function" == typeof (e = "*" === t.filename && "*" !== t.title && void 0 !== t.title && null !== t.title && "" !== t.title ? t.title : t.filename) ? e(t, n) : e) ? null : (e = (e = -1 !== e.indexOf("*") ? e.replace(/\*/g, x("head > title").text()).trim() : e).replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "")) + (r(t.extension, t, n) || "") }, r = function (t, n, e) { return null == t ? null : "function" == typeof t ? t(n, e) : t }, a = function (t, n) { t = r(t.title, t, n); return null === t ? null : -1 !== t.indexOf("*") ? t.replace(/\*/g, x("head > title").text() || "Exported data") : t }, l = function (t, n, e, o) { e = r(e, n, t); return null === e ? null : (n = x("caption", t.table().container()).eq(0), "*" === e ? n.css("caption-side") !== o ? null : n.length ? n.text() : "" : e) }, c = x("<textarea/>")[0], u = function (i, t) { for (var s = x.extend(!0, {}, { rows: null, columns: "", modifier: { search: "applied", order: "applied" }, orthogonal: "display", stripHtml: !0, stripNewlines: !0, decodeEntities: !0, trim: !0, format: { header: function (t) { return _.stripData(t, s) }, footer: function (t) { return _.stripData(t, s) }, body: function (t) { return _.stripData(t, s) } }, customizeData: null, customizeZip: null }, t), t = i.columns(s.columns).indexes().map(function (t) { var n = i.column(t); return s.format.header(n.title(), t, n.header()) }).toArray(), n = i.table().footer() ? i.columns(s.columns).indexes().map(function (t) { var n, e = i.column(t).footer(), o = ""; return e && (o = ((n = x(".dt-column-title", e)).length ? n : x(e)).html()), s.format.footer(o, t, e) }).toArray() : null, e = x.extend({}, s.modifier), o = (i.select && "function" == typeof i.select.info && void 0 === e.selected && i.rows(s.rows, x.extend({ selected: !0 }, e)).any() && x.extend(e, { selected: !0 }), i.rows(s.rows, e).indexes().toArray()), o = i.cells(o, s.columns, { order: e.order }), r = o.render(s.orthogonal).toArray(), a = o.nodes().toArray(), l = o.indexes().toArray(), c = i.columns(s.columns).count(), u = [], d = 0, f = 0, p = 0 < c ? r.length / c : 0; f < p; f++) { for (var h = [c], b = 0; b < c; b++)h[b] = s.format.body(r[d], l[d].row, l[d].column, a[d]), d++; u[f] = h } e = { header: t, headerStructure: A(s.format.header, i.table().header.structure(s.columns)), footer: n, footerStructure: A(s.format.footer, i.table().footer.structure(s.columns)), body: u }; return s.customizeData && s.customizeData(e), e }; function A(t, n) { for (var e = 0; e < n.length; e++)for (var o = 0; o < n[e].length; o++) { var i = n[e][o]; i && (i.title = t(i.title, o, i.cell)) } return n } function t(t, n) { t = new e.Api(t), n = n || t.init().buttons || e.defaults.buttons; return new _(t, n).container() } return x.fn.dataTable.Buttons = _, x.fn.DataTable.Buttons = _, x(m).on("init.dt plugin-init.dt", function (t, n) { "dt" === t.namespace && (t = n.oInit.buttons || e.defaults.buttons) && !n._buttons && new _(n, t).container() }), e.ext.feature.push({ fnInit: t, cFeature: "B" }), e.feature && e.feature.register("buttons", t), e });


/*! Responsive 3.0.2
 * © SpryMedia Ltd - datatables.net/license
 */
!function (n) { var i, r; "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function (e) { return n(e, window, document) }) : "object" == typeof exports ? (i = require("jquery"), r = function (e, t) { t.fn.dataTable || require("datatables.net")(e, t) }, "undefined" == typeof window ? module.exports = function (e, t) { return e = e || window, t = t || i(e), r(e, t), n(t, e, e.document) } : (r(window, i), module.exports = n(i, window, window.document))) : n(jQuery, window, document) }(function (b, y, d) { "use strict"; function a(e, t) { if (!i.versionCheck || !i.versionCheck("2")) throw "DataTables Responsive requires DataTables 2 or newer"; this.s = { childNodeStore: {}, columns: [], current: [], dt: new i.Api(e) }, this.s.dt.settings()[0].responsive || (t && "string" == typeof t.details ? t.details = { type: t.details } : t && !1 === t.details ? t.details = { type: !1 } : t && !0 === t.details && (t.details = { type: "inline" }), this.c = b.extend(!0, {}, a.defaults, i.defaults.responsive, t), (e.responsive = this)._constructor()) } var i = b.fn.dataTable, e = (b.extend(a.prototype, { _constructor: function () { var o = this, r = this.s.dt, t = b(y).innerWidth(), e = (r.settings()[0]._responsive = this, b(y).on("orientationchange.dtr", i.util.throttle(function () { var e = b(y).innerWidth(); e !== t && (o._resize(), t = e) })), r.on("row-created.dtr", function (e, t, n, i) { -1 !== b.inArray(!1, o.s.current) && b(">td, >th", t).each(function (e) { e = r.column.index("toData", e); !1 === o.s.current[e] && b(this).css("display", "none").addClass("dtr-hidden") }) }), r.on("destroy.dtr", function () { r.off(".dtr"), b(r.table().body()).off(".dtr"), b(y).off("resize.dtr orientationchange.dtr"), r.cells(".dtr-control").nodes().to$().removeClass("dtr-control"), b(r.table().node()).removeClass("dtr-inline collapsed"), b.each(o.s.current, function (e, t) { !1 === t && o._setColumnVis(e, !0) }) }), this.c.breakpoints.sort(function (e, t) { return e.width < t.width ? 1 : e.width > t.width ? -1 : 0 }), this._classLogic(), this._resizeAuto(), this.c.details); !1 !== e.type && (o._detailsInit(), r.on("column-visibility.dtr", function () { o._timer && clearTimeout(o._timer), o._timer = setTimeout(function () { o._timer = null, o._classLogic(), o._resizeAuto(), o._resize(!0), o._redrawChildren() }, 100) }), r.on("draw.dtr", function () { o._redrawChildren() }), b(r.table().node()).addClass("dtr-" + e.type)), r.on("column-reorder.dtr", function (e, t, n) { o._classLogic(), o._resizeAuto(), o._resize(!0) }), r.on("column-sizing.dtr", function () { o._resizeAuto(), o._resize() }), r.on("column-calc.dt", function (e, t) { for (var n = o.s.current, i = 0; i < n.length; i++) { var r = t.visible.indexOf(i); !1 === n[i] && 0 <= r && t.visible.splice(r, 1) } }), r.on("preXhr.dtr", function () { var e = []; r.rows().every(function () { this.child.isShown() && e.push(this.id(!0)) }), r.one("draw.dtr", function () { o._resizeAuto(), o._resize(), r.rows(e).every(function () { o._detailsDisplay(this, !1) }) }) }), r.on("draw.dtr", function () { o._controlClass() }).on("init.dtr", function (e, t, n) { "dt" === e.namespace && (o._resizeAuto(), o._resize()) }), this._resize() }, _colGroupAttach: function (e, t, n) { var i = null; if (t[n].get(0).parentNode !== e[0]) { for (var r = n + 1; r < t.length; r++)if (e[0] === t[r].get(0).parentNode) { i = r; break } null !== i ? t[n].insertBefore(t[i][0]) : e.append(t[n]) } }, _childNodes: function (e, t, n) { var i = t + "-" + n; if (this.s.childNodeStore[i]) return this.s.childNodeStore[i]; for (var r = [], o = e.cell(t, n).node().childNodes, s = 0, d = o.length; s < d; s++)r.push(o[s]); return this.s.childNodeStore[i] = r }, _childNodesRestore: function (e, t, n) { var i = t + "-" + n; if (this.s.childNodeStore[i]) { var r = e.cell(t, n).node(), e = this.s.childNodeStore[i]; if (0 < e.length) { for (var o = e[0].parentNode.childNodes, s = [], d = 0, a = o.length; d < a; d++)s.push(o[d]); for (var l = 0, c = s.length; l < c; l++)r.appendChild(s[l]) } this.s.childNodeStore[i] = void 0 } }, _columnsVisiblity: function (n) { for (var i = this.s.dt, e = this.s.columns, t = e.map(function (e, t) { return { columnIdx: t, priority: e.priority } }).sort(function (e, t) { return e.priority !== t.priority ? e.priority - t.priority : e.columnIdx - t.columnIdx }), r = b.map(e, function (e, t) { return !1 === i.column(t).visible() ? "not-visible" : (!e.auto || null !== e.minWidth) && (!0 === e.auto ? "-" : -1 !== b.inArray(n, e.includeIn)) }), o = 0, s = 0, d = r.length; s < d; s++)!0 === r[s] && (o += e[s].minWidth); var a = i.settings()[0].oScroll, a = a.sY || a.sX ? a.iBarWidth : 0, l = i.table().container().offsetWidth - a - o; for (s = 0, d = r.length; s < d; s++)e[s].control && (l -= e[s].minWidth); var c = !1; for (s = 0, d = t.length; s < d; s++) { var u = t[s].columnIdx; "-" === r[u] && !e[u].control && e[u].minWidth && (c || l - e[u].minWidth < 0 ? r[u] = !(c = !0) : r[u] = !0, l -= e[u].minWidth) } var h = !1; for (s = 0, d = e.length; s < d; s++)if (!e[s].control && !e[s].never && !1 === r[s]) { h = !0; break } for (s = 0, d = e.length; s < d; s++)e[s].control && (r[s] = h), "not-visible" === r[s] && (r[s] = !1); return -1 === b.inArray(!0, r) && (r[0] = !0), r }, _classLogic: function () { function d(e, t, n, i) { var r, o, s; if (n) { if ("max-" === n) for (r = a._find(t).width, o = 0, s = l.length; o < s; o++)l[o].width <= r && u(e, l[o].name); else if ("min-" === n) for (r = a._find(t).width, o = 0, s = l.length; o < s; o++)l[o].width >= r && u(e, l[o].name); else if ("not-" === n) for (o = 0, s = l.length; o < s; o++)-1 === l[o].name.indexOf(i) && u(e, l[o].name) } else c[e].includeIn.push(t) } var a = this, l = this.c.breakpoints, c = this.s.dt.columns().eq(0).map(function (e) { var e = this.column(e), t = e.header().className, n = e.init().responsivePriority, e = e.header().getAttribute("data-priority"); return void 0 === n && (n = null == e ? 1e4 : +e), { className: t, includeIn: [], auto: !1, control: !1, never: !!t.match(/\b(dtr\-)?never\b/), priority: n } }), u = function (e, t) { e = c[e].includeIn; -1 === b.inArray(t, e) && e.push(t) }; c.each(function (e, r) { for (var t = e.className.split(" "), o = !1, n = 0, i = t.length; n < i; n++) { var s = t[n].trim(); if ("all" === s || "dtr-all" === s) return o = !0, void (e.includeIn = b.map(l, function (e) { return e.name })); if ("none" === s || "dtr-none" === s || e.never) return void (o = !0); if ("control" === s || "dtr-control" === s) return o = !0, void (e.control = !0); b.each(l, function (e, t) { var n = t.name.split("-"), i = new RegExp("(min\\-|max\\-|not\\-)?(" + n[0] + ")(\\-[_a-zA-Z0-9])?"), i = s.match(i); i && (o = !0, i[2] === n[0] && i[3] === "-" + n[1] ? d(r, t.name, i[1], i[2] + i[3]) : i[2] !== n[0] || i[3] || d(r, t.name, i[1], i[2])) }) } o || (e.auto = !0) }), this.s.columns = c }, _controlClass: function () { var e, t, n; "inline" === this.c.details.type && (e = this.s.dt, t = this.s.current, n = b.inArray(!0, t), e.cells(null, function (e) { return e !== n }, { page: "current" }).nodes().to$().filter(".dtr-control").removeClass("dtr-control"), e.cells(null, n, { page: "current" }).nodes().to$().addClass("dtr-control")) }, _detailsDisplay: function (t, n) { function e(e) { b(t.node()).toggleClass("dtr-expanded", !1 !== e), b(o.table().node()).triggerHandler("responsive-display.dt", [o, t, e, n]) } var i, r = this, o = this.s.dt, s = this.c.details; s && !1 !== s.type && (i = "string" == typeof s.renderer ? a.renderer[s.renderer]() : s.renderer, "boolean" == typeof (s = s.display(t, n, function () { return i.call(r, o, t[0][0], r._detailsObj(t[0])) }, function () { e(!1) }))) && e(s) }, _detailsInit: function () { var n = this, i = this.s.dt, e = this.c.details, r = ("inline" === e.type && (e.target = "td.dtr-control, th.dtr-control"), i.on("draw.dtr", function () { n._tabIndexes() }), n._tabIndexes(), b(i.table().body()).on("keyup.dtr", "td, th", function (e) { 13 === e.keyCode && b(this).data("dtr-keyboard") && b(this).click() }), e.target), e = "string" == typeof r ? r : "td, th"; void 0 === r && null === r || b(i.table().body()).on("click.dtr mousedown.dtr mouseup.dtr", e, function (e) { if (b(i.table().node()).hasClass("collapsed") && -1 !== b.inArray(b(this).closest("tr").get(0), i.rows().nodes().toArray())) { if ("number" == typeof r) { var t = r < 0 ? i.columns().eq(0).length + r : r; if (i.cell(this).index().column !== t) return } t = i.row(b(this).closest("tr")); "click" === e.type ? n._detailsDisplay(t, !1) : "mousedown" === e.type ? b(this).css("outline", "none") : "mouseup" === e.type && b(this).trigger("blur").css("outline", "") } }) }, _detailsObj: function (n) { var i = this, r = this.s.dt; return b.map(this.s.columns, function (e, t) { if (!e.never && !e.control) return { className: r.settings()[0].aoColumns[t].sClass, columnIndex: t, data: r.cell(n, t).render(i.c.orthogonal), hidden: r.column(t).visible() && !i.s.current[t], rowIndex: n, title: r.column(t).title() } }) }, _find: function (e) { for (var t = this.c.breakpoints, n = 0, i = t.length; n < i; n++)if (t[n].name === e) return t[n] }, _redrawChildren: function () { var n = this, i = this.s.dt; i.rows({ page: "current" }).iterator("row", function (e, t) { n._detailsDisplay(i.row(t), !0) }) }, _resize: function (n) { for (var e, i = this, r = this.s.dt, t = b(y).innerWidth(), o = this.c.breakpoints, s = o[0].name, d = this.s.columns, a = this.s.current.slice(), l = o.length - 1; 0 <= l; l--)if (t <= o[l].width) { s = o[l].name; break } var c = this._columnsVisiblity(s), u = (this.s.current = c, !1); for (l = 0, e = d.length; l < e; l++)if (!1 === c[l] && !d[l].never && !d[l].control && !1 == !r.column(l).visible()) { u = !0; break } b(r.table().node()).toggleClass("collapsed", u); var h = !1, p = 0, f = r.settings()[0], m = b(r.table().node()).children("colgroup"), v = f.aoColumns.map(function (e) { return e.colEl }); r.columns().eq(0).each(function (e, t) { r.column(e).visible() && (!0 === c[t] && p++, !n && c[t] === a[t] || (h = !0, i._setColumnVis(e, c[t])), c[t] ? i._colGroupAttach(m, v, t) : v[t].detach()) }), h && (r.columns.adjust(), this._redrawChildren(), b(r.table().node()).trigger("responsive-resize.dt", [r, this._responsiveOnlyHidden()]), 0 === r.page.info().recordsDisplay) && b("td", r.table().body()).eq(0).attr("colspan", p), i._controlClass() }, _resizeAuto: function () { var t = this.s.dt, n = this.s.columns, r = this, o = t.columns().indexes().filter(function (e) { return t.column(e).visible() }); if (this.c.auto && -1 !== b.inArray(!0, b.map(n, function (e) { return e.auto }))) { for (var e = t.table().node().cloneNode(!1), i = b(t.table().header().cloneNode(!1)).appendTo(e), s = b(t.table().footer().cloneNode(!1)).appendTo(e), d = b(t.table().body()).clone(!1, !1).empty().appendTo(e), a = (e.style.width = "auto", t.table().header.structure(o).forEach(e => { e = e.filter(function (e) { return !!e }).map(function (e) { return b(e.cell).clone(!1).css("display", "table-cell").css("width", "auto").css("min-width", 0) }); b("<tr/>").append(e).appendTo(i) }), b("<tr/>").appendTo(d)), l = 0; l < o.count(); l++)a.append("<td/>"); t.rows({ page: "current" }).every(function (n) { var i, e = this.node(); e && (i = e.cloneNode(!1), t.cells(n, o).every(function (e, t) { t = r.s.childNodeStore[n + "-" + t]; (t ? b(this.node().cloneNode(!1)).append(b(t).clone()) : b(this.node()).clone(!1)).appendTo(i) }), d.append(i)) }), d.find("th, td").css("display", ""), t.table().footer.structure(o).forEach(e => { e = e.filter(function (e) { return !!e }).map(function (e) { return b(e.cell).clone(!1).css("display", "table-cell").css("width", "auto").css("min-width", 0) }); b("<tr/>").append(e).appendTo(s) }), "inline" === this.c.details.type && b(e).addClass("dtr-inline collapsed"), b(e).find("[name]").removeAttr("name"), b(e).css("position", "relative"); e = b("<div/>").css({ width: 1, height: 1, overflow: "hidden", clear: "both" }).append(e); e.insertBefore(t.table().node()), a.children().each(function (e) { e = t.column.index("fromVisible", e); n[e].minWidth = this.offsetWidth || 0 }), e.remove() } }, _responsiveOnlyHidden: function () { var n = this.s.dt; return b.map(this.s.current, function (e, t) { return !1 === n.column(t).visible() || e }) }, _setColumnVis: function (e, t) { var n = this, i = this.s.dt, r = t ? "" : "none"; this._setHeaderVis(e, t, i.table().header.structure()), this._setHeaderVis(e, t, i.table().footer.structure()), i.column(e).nodes().to$().css("display", r).toggleClass("dtr-hidden", !t), b.isEmptyObject(this.s.childNodeStore) || i.cells(null, e).indexes().each(function (e) { n._childNodesRestore(i, e.row, e.column) }) }, _setHeaderVis: function (n, i, e) { var r = this, o = i ? "" : "none"; e.forEach(function (e) { if (e[n]) b(e[n].cell).css("display", o).toggleClass("dtr-hidden", !i); else for (var t = n; 0 <= t;) { if (e[t]) { e[t].cell.colSpan = r._colspan(e, t); break } t-- } }) }, _colspan: function (e, t) { for (var n = 1, i = t + 1; i < e.length; i++)if (null === e[i] && this.s.current[i]) n++; else if (e[i]) break; return n }, _tabIndexes: function () { var e = this.s.dt, t = e.cells({ page: "current" }).nodes().to$(), n = e.settings()[0], i = this.c.details.target; t.filter("[data-dtr-keyboard]").removeData("[data-dtr-keyboard]"), ("number" == typeof i ? e.cells(null, i, { page: "current" }).nodes().to$() : b(i = "td:first-child, th:first-child" === i ? ">td:first-child, >th:first-child" : i, e.rows({ page: "current" }).nodes())).attr("tabIndex", n.iTabIndex).data("dtr-keyboard", 1) } }), a.defaults = { breakpoints: a.breakpoints = [{ name: "desktop", width: 1 / 0 }, { name: "tablet-l", width: 1024 }, { name: "tablet-p", width: 768 }, { name: "mobile-l", width: 480 }, { name: "mobile-p", width: 320 }], auto: !0, details: { display: (a.display = { childRow: function (e, t, n) { var i = b(e.node()); return t ? i.hasClass("dtr-expanded") ? (e.child(n(), "child").show(), !0) : void 0 : i.hasClass("dtr-expanded") ? (e.child(!1), !1) : !1 !== (t = n()) && (e.child(t, "child").show(), !0) }, childRowImmediate: function (e, t, n) { var i = b(e.node()); return !t && i.hasClass("dtr-expanded") || !e.responsive.hasHidden() ? (e.child(!1), !1) : !1 !== (t = n()) && (e.child(t, "child").show(), !0) }, modal: function (s) { return function (e, t, n, i) { n = n(); if (!1 === n) return !1; if (t) { if (!(o = b("div.dtr-modal-content")).length || e.index() !== o.data("dtr-row-idx")) return null; o.empty().append(n) } else { var r = function () { o.remove(), b(d).off("keypress.dtr"), b(e.node()).removeClass("dtr-expanded"), i() }, o = b('<div class="dtr-modal"/>').append(b('<div class="dtr-modal-display"/>').append(b('<div class="dtr-modal-content"/>').data("dtr-row-idx", e.index()).append(n)).append(b('<div class="dtr-modal-close">&times;</div>').click(function () { r() }))).append(b('<div class="dtr-modal-background"/>').click(function () { r() })).appendTo("body"); b(e.node()).addClass("dtr-expanded"), b(d).on("keyup.dtr", function (e) { 27 === e.keyCode && (e.stopPropagation(), r()) }) } return s && s.header && b("div.dtr-modal-content").prepend("<h2>" + s.header(e) + "</h2>"), !0 } } }).childRow, renderer: (a.renderer = { listHiddenNodes: function () { return function (i, e, t) { var r = this, o = b('<ul data-dtr-index="' + e + '" class="dtr-details"/>'), s = !1; return b.each(t, function (e, t) { var n; t.hidden && (n = t.className ? 'class="' + t.className + '"' : "", b("<li " + n + ' data-dtr-index="' + t.columnIndex + '" data-dt-row="' + t.rowIndex + '" data-dt-column="' + t.columnIndex + '"><span class="dtr-title">' + t.title + "</span> </li>").append(b('<span class="dtr-data"/>').append(r._childNodes(i, t.rowIndex, t.columnIndex))).appendTo(o), s = !0) }), !!s && o } }, listHidden: function () { return function (e, t, n) { n = b.map(n, function (e) { var t = e.className ? 'class="' + e.className + '"' : ""; return e.hidden ? "<li " + t + ' data-dtr-index="' + e.columnIndex + '" data-dt-row="' + e.rowIndex + '" data-dt-column="' + e.columnIndex + '"><span class="dtr-title">' + e.title + '</span> <span class="dtr-data">' + e.data + "</span></li>" : "" }).join(""); return !!n && b('<ul data-dtr-index="' + t + '" class="dtr-details"/>').append(n) } }, tableAll: function (i) { return i = b.extend({ tableClass: "" }, i), function (e, t, n) { n = b.map(n, function (e) { return "<tr " + (e.className ? 'class="' + e.className + '"' : "") + ' data-dt-row="' + e.rowIndex + '" data-dt-column="' + e.columnIndex + '"><td>' + e.title + ":</td> <td>" + e.data + "</td></tr>" }).join(""); return b('<table class="' + i.tableClass + ' dtr-details" width="100%"/>').append(n) } } }).listHidden(), target: 0, type: "inline" }, orthogonal: "display" }, b.fn.dataTable.Api); return e.register("responsive()", function () { return this }), e.register("responsive.index()", function (e) { return { column: (e = b(e)).data("dtr-index"), row: e.parent().data("dtr-index") } }), e.register("responsive.rebuild()", function () { return this.iterator("table", function (e) { e._responsive && e._responsive._classLogic() }) }), e.register("responsive.recalc()", function () { return this.iterator("table", function (e) { e._responsive && (e._responsive._resizeAuto(), e._responsive._resize()) }) }), e.register("responsive.hasHidden()", function () { var e = this.context[0]; return !!e._responsive && -1 !== b.inArray(!1, e._responsive._responsiveOnlyHidden()) }), e.registerPlural("columns().responsiveHidden()", "column().responsiveHidden()", function () { return this.iterator("column", function (e, t) { return !!e._responsive && e._responsive._responsiveOnlyHidden()[t] }, 1) }), a.version = "3.0.2", b.fn.dataTable.Responsive = a, b.fn.DataTable.Responsive = a, b(d).on("preInit.dt.dtr", function (e, t, n) { "dt" === e.namespace && (b(t.nTable).hasClass("responsive") || b(t.nTable).hasClass("dt-responsive") || t.oInit.responsive || i.defaults.responsive) && !1 !== (e = t.oInit.responsive) && new a(t, b.isPlainObject(e) ? e : {}) }), i });
/*! Scroller 2.4.3
 * © SpryMedia Ltd - datatables.net/license
 */
!function (o) { var e, i; "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function (t) { return o(t, window, document) }) : "object" == typeof exports ? (e = require("jquery"), i = function (t, s) { s.fn.dataTable || require("datatables.net")(t, s) }, "undefined" == typeof window ? module.exports = function (t, s) { return t = t || window, s = s || e(t), i(t, s), o(s, t, t.document) } : (i(window, e), module.exports = o(e, window, window.document))) : o(jQuery, window, document) }(function (d, l, o) { "use strict"; function i(t, s) { this instanceof i ? (void 0 === s && (s = {}), t = d.fn.dataTable.Api(t), this.s = { dt: t.settings()[0], dtApi: t, tableTop: 0, tableBottom: 0, redrawTop: 0, redrawBottom: 0, autoHeight: !0, viewportRows: 0, stateTO: null, stateSaveThrottle: function () { }, drawTO: null, heights: { jump: null, page: null, virtual: null, scroll: null, row: null, viewport: null, labelHeight: 0, xbar: 0 }, topRowFloat: 0, scrollDrawDiff: null, loaderVisible: !1, forceReposition: !1, baseRowTop: 0, baseScrollTop: 0, mousedown: !1, lastScrollTop: 0 }, this.s = d.extend(this.s, i.oDefaults, s), this.s.heights.row = this.s.rowHeight, this.dom = { force: o.createElement("div"), label: d('<div class="dts_label">0</div>'), scroller: null, table: null, loader: null }, this.s.dt.oScroller || (this.s.dt.oScroller = this).construct()) : alert("Scroller warning: Scroller must be initialised with the 'new' keyword.") } var a = d.fn.dataTable, t = (d.extend(i.prototype, { measure: function (t) { this.s.autoHeight && this._calcRowHeight(); var s = this.s.heights, o = (s.row && (s.viewport = this._parseHeight(d(this.dom.scroller).css("max-height")), this.s.viewportRows = parseInt(s.viewport / s.row, 10) + 1, this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer), this.dom.label.outerHeight()); s.xbar = this.dom.scroller.offsetHeight - this.dom.scroller.clientHeight, s.labelHeight = o, void 0 !== t && !t || this.s.dtApi.draw(!1) }, pageInfo: function () { var t = this.s.dt, s = this.dom.scroller.scrollTop, t = t.fnRecordsDisplay(), o = Math.ceil(this.pixelsToRow(s + this.s.heights.viewport, !1, this.s.ani)); return { start: Math.floor(this.pixelsToRow(s, !1, this.s.ani)), end: t < o ? t - 1 : o - 1 } }, pixelsToRow: function (t, s, o) { t -= this.s.baseScrollTop, o = o ? (this._domain("physicalToVirtual", this.s.baseScrollTop) + t) / this.s.heights.row : t / this.s.heights.row + this.s.baseRowTop; return s || void 0 === s ? parseInt(o, 10) : o }, rowToPixels: function (t, s, o) { t -= this.s.baseRowTop, o = o ? this._domain("virtualToPhysical", this.s.baseScrollTop) : this.s.baseScrollTop; return o += t * this.s.heights.row, s || void 0 === s ? parseInt(o, 10) : o }, scrollToRow: function (t, s) { var o = this, e = !1, i = this.rowToPixels(t), r = t - (this.s.displayBuffer - 1) / 2 * this.s.viewportRows; r < 0 && (r = 0), void 0 === (s = (i > this.s.redrawBottom || i < this.s.redrawTop) && this.s.dt._iDisplayStart !== r && (e = !0, i = this._domain("virtualToPhysical", t * this.s.heights.row), this.s.redrawTop < i) && i < this.s.redrawBottom ? !(this.s.forceReposition = !0) : s) || s ? (this.s.ani = e, d(this.dom.scroller).animate({ scrollTop: i }, function () { setTimeout(function () { o.s.ani = !1 }, 250) })) : d(this.dom.scroller).scrollTop(i) }, construct: function () { var e = this, t = this.s.dtApi; if (!this.s.dt.oFeatures.bPaginate) throw new Error("Pagination must be enabled for Scroller to operate"); this.dom.force.style.position = "relative", this.dom.force.style.top = "0px", this.dom.force.style.left = "0px", this.dom.force.style.width = "1px", this.dom.scroller = t.table().node().parentNode, this.dom.scroller.appendChild(this.dom.force), this.dom.scroller.style.position = "relative", this.dom.table = d(">table", this.dom.scroller)[0], this.dom.table.style.position = "absolute", this.dom.table.style.top = "0px", this.dom.table.style.left = "0px", d(t.table().container()).addClass("dts DTS"), this.dom.label.appendTo(this.dom.scroller), this.s.heights.row && "auto" != this.s.heights.row && (this.s.autoHeight = !1), this.s.ingnoreScroll = !0, d(this.dom.scroller).on("scroll.dt-scroller", function (t) { e._scroll.call(e) }), d(this.dom.scroller).on("touchstart.dt-scroller", function () { e._scroll.call(e) }), d(this.dom.scroller).on("mousedown.dt-scroller", function () { e.s.mousedown = !0 }).on("mouseup.dt-scroller", function () { e.s.labelVisible = !1, e.s.mousedown = !1, e.dom.label.css("display", "none") }), d(l).on("resize.dt-scroller", function () { e.measure(!1), e._info() }); var i = !0, r = t.state.loaded(); t.on("stateSaveParams.scroller", function (t, s, o) { i && r ? (o.scroller = r.scroller, i = !1, o.scroller && (e.s.lastScrollTop = o.scroller.scrollTop)) : o.scroller = { topRow: e.s.topRowFloat, baseRowTop: e.s.baseRowTop } }), t.on("stateLoadParams.scroller", function (t, s, o) { void 0 !== o.scroller && e.scrollToRow(o.scroller.topRow) }), this.measure(!1), r && r.scroller && (this.s.topRowFloat = r.scroller.topRow, this.s.baseRowTop = r.scroller.baseRowTop, this.s.baseScrollTop = this.s.baseRowTop * this.s.heights.row, r.scroller.scrollTop = this._domain("physicalToVirtual", this.s.topRowFloat * this.s.heights.row)), e.s.stateSaveThrottle = a.util.throttle(function () { e.s.dtApi.state.save() }, 500), t.on("init.scroller", function () { e.measure(!1), e.s.scrollType = "jump", e._draw(), t.on("draw.scroller", function () { e._draw() }) }), t.on("preDraw.dt.scroller", function () { e._scrollForce() }), t.on("destroy.scroller", function () { d(l).off("resize.dt-scroller"), d(e.dom.scroller).off(".dt-scroller"), d(e.s.dt.nTable).off(".scroller"), d(e.s.dt.nTableWrapper).removeClass("DTS"), d("div.DTS_Loading", e.dom.scroller.parentNode).remove(), e.dom.table.style.position = "", e.dom.table.style.top = "", e.dom.table.style.left = "" }) }, _calcRowHeight: function () { var t = this.s.dt, s = t.nTable, o = s.cloneNode(!1), e = d("<tbody/>").appendTo(o), t = t.oClasses, t = a.versionCheck("2") ? { container: t.container, scroller: t.scrolling.container, body: t.scrolling.body } : { container: t.sWrapper, scroller: t.sScrollWrapper, body: t.sScrollBody }, i = d('<div class="' + t.container + ' DTS"><div class="' + t.scroller + '"><div class="' + t.body + '"></div></div></div>'), r = (d("tbody tr:lt(4)", s).clone().appendTo(e), d("tr", e).length); if (1 === r) e.prepend("<tr><td>&#160;</td></tr>"), e.append("<tr><td>&#160;</td></tr>"); else for (; r < 3; r++)e.append("<tr><td>&#160;</td></tr>"); d("div." + t.body, i).append(o); t = this.s.dt.nHolding || s.parentNode; d(t).is(":visible") || (t = "body"), i.find("input").removeAttr("name"), i.appendTo(t), this.s.heights.row = d("tr", e).eq(1).outerHeight(), i.remove() }, _draw: function () { var t = this, s = this.s.heights, o = this.dom.scroller.scrollTop, e = d(this.s.dt.nTable).height(), i = this.s.dt._iDisplayStart, r = this.s.dt._iDisplayLength, l = this.s.dt.fnRecordsDisplay(), a = o + s.viewport, n = (this.s.skip = !0, !this.s.dt.bSorted && !this.s.dt.bFiltered || 0 !== i || this.s.dt._drawHold || (this.s.topRowFloat = 0), o = "jump" === this.s.scrollType ? this._domain("virtualToPhysical", this.s.topRowFloat * s.row) : o, this.s.baseScrollTop = o, this.s.baseRowTop = this.s.topRowFloat, o - (this.s.topRowFloat - i) * s.row), i = (0 === i ? n = 0 : l <= i + r ? n = s.scroll - e : n + e < a && (this.s.baseScrollTop += 1 + ((l = a - e) - n), n = l), this.dom.table.style.top = n + "px", this.s.tableTop = n, this.s.tableBottom = e + this.s.tableTop, (o - this.s.tableTop) * this.s.boundaryScale); this.s.redrawTop = o - i, this.s.redrawBottom = o + i > s.scroll - s.viewport - s.row ? s.scroll - s.viewport - s.row : o + i, this.s.skip = !1, t.s.ingnoreScroll && (this.s.dt.oFeatures.bStateSave && null !== this.s.dt.oLoadedState && void 0 !== this.s.dt.oLoadedState.scroller ? ((r = !(!this.s.dt.sAjaxSource && !t.s.dt.ajax || this.s.dt.oFeatures.bServerSide)) && 2 <= this.s.dt.iDraw || !r && 1 <= this.s.dt.iDraw) && setTimeout(function () { d(t.dom.scroller).scrollTop(t.s.dt.oLoadedState.scroller.scrollTop), setTimeout(function () { t.s.ingnoreScroll = !1 }, 0) }, 0) : t.s.ingnoreScroll = !1), this.s.dt.oFeatures.bInfo && setTimeout(function () { t._info.call(t) }, 0), d(this.s.dt.nTable).triggerHandler("position.dts.dt", n) }, _domain: function (t, s) { var o, e = this.s.heights, i = 1e4; return e.virtual === e.scroll || s < i ? s : "virtualToPhysical" === t && s >= e.virtual - i ? (o = e.virtual - s, e.scroll - o) : "physicalToVirtual" === t && s >= e.scroll - i ? (o = e.scroll - s, e.virtual - o) : (e = i - (o = (e.virtual - i - i) / (e.scroll - i - i)) * i, "virtualToPhysical" === t ? (s - e) / o : o * s + e) }, _info: function () { if (this.s.dt.oFeatures.bInfo) { var t = this.s.dt, s = this.s.dtApi, o = t.oLanguage, e = s.page.info(), i = e.recordsDisplay, e = e.recordsTotal, r = (this.s.lastScrollTop - this.s.baseScrollTop) / this.s.heights.row, r = Math.floor(this.s.baseRowTop + r) + 1, l = (r = "jump" === this.s.scrollType ? Math.floor(this.s.topRowFloat) + 1 : r) + Math.floor(this.s.heights.viewport / this.s.heights.row), l = i < l ? i : l, a = 0 === i && i == e ? o.sInfoEmpty + o.sInfoPostFix : 0 === i ? o.sInfoEmpty + " " + o.sInfoFiltered + o.sInfoPostFix : i == e ? o.sInfo + o.sInfoPostFix : o.sInfo + " " + o.sInfoFiltered + o.sInfoPostFix, o = (a = this._macros(a, r, l, e, i), o.fnInfoCallback), n = (o && (a = o.call(t.oInstance, t, r, l, e, i, a)), t.aanFeatures.i); if (void 0 !== n) { for (var h = 0, c = n.length; h < c; h++)d(n[h]).html(a); d(t.nTable).triggerHandler("info.dt") } d("div.dt-info", s.table().container()).each(function () { d(this).html(a), s.trigger("info", [s.settings()[0], this, a]) }) } }, _macros: function (t, s, o, e, i) { var r = this.s.dtApi, l = this.s.dt, a = l.fnFormatNumber; return t.replace(/_START_/g, a.call(l, s)).replace(/_END_/g, a.call(l, o)).replace(/_MAX_/g, a.call(l, e)).replace(/_TOTAL_/g, a.call(l, i)).replace(/_ENTRIES_/g, r.i18n("entries", "")).replace(/_ENTRIES-MAX_/g, r.i18n("entries", "", e)).replace(/_ENTRIES-TOTAL_/g, r.i18n("entries", "", i)) }, _parseHeight: function (t) { var s, o, t = /^([+-]?(?:\d+(?:\.\d+)?|\.\d+))(px|em|rem|vh)$/.exec(t); return null !== t && (o = parseFloat(t[1]), "px" === (t = t[2]) ? s = o : "vh" === t ? s = o / 100 * d(l).height() : "rem" === t ? s = o * parseFloat(d(":root").css("font-size")) : "em" === t && (s = o * parseFloat(d("body").css("font-size"))), s) || 0 }, _scroll: function () { var t, s = this, o = this.s.heights, e = this.dom.scroller.scrollTop; this.s.skip || this.s.ingnoreScroll || e !== this.s.lastScrollTop && (this.s.dt.bFiltered || this.s.dt.bSorted ? this.s.lastScrollTop = 0 : (clearTimeout(this.s.stateTO), this.s.stateTO = setTimeout(function () { s.s.dtApi.state.save(), s._info() }, 250), this.s.scrollType = Math.abs(e - this.s.lastScrollTop) > o.viewport ? "jump" : "cont", this.s.topRowFloat = "cont" === this.s.scrollType ? this.pixelsToRow(e, !1, !1) : this._domain("physicalToVirtual", e) / o.row, this.s.topRowFloat < 0 && (this.s.topRowFloat = 0), this.s.forceReposition || e < this.s.redrawTop || e > this.s.redrawBottom ? (t = Math.ceil((this.s.displayBuffer - 1) / 2 * this.s.viewportRows), t = parseInt(this.s.topRowFloat, 10) - t, this.s.forceReposition = !1, t <= 0 ? t = 0 : t + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay() ? (t = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength) < 0 && (t = 0) : t % 2 != 0 && t++, (this.s.targetTop = t) != this.s.dt._iDisplayStart && (this.s.tableTop = d(this.s.dt.nTable).offset().top, this.s.tableBottom = d(this.s.dt.nTable).height() + this.s.tableTop, t = function () { s.s.dt._iDisplayStart = s.s.targetTop, s.s.dtApi.draw("page") }, this.s.dt.oFeatures.bServerSide ? (this.s.forceReposition = !0, d(this.s.dt.nTable).triggerHandler("scroller-will-draw.dt"), a.versionCheck("2") ? s.s.dtApi.processing(!0) : this.s.dt.oApi._fnProcessingDisplay(this.s.dt, !0), clearTimeout(this.s.drawTO), this.s.drawTO = setTimeout(t, this.s.serverWait)) : t())) : this.s.topRowFloat = this.pixelsToRow(e, !1, !0), this._info(), this.s.lastScrollTop = e, this.s.stateSaveThrottle(), "jump" === this.s.scrollType && this.s.mousedown && (this.s.labelVisible = !0), this.s.labelVisible && (t = (o.viewport - o.labelHeight - o.xbar) / o.scroll, this.dom.label.html(this.s.dt.fnFormatNumber(parseInt(this.s.topRowFloat, 10) + 1)).css("top", e + e * t).css("display", "block")))) }, _scrollForce: function () { var t = this.s.heights; t.virtual = t.row * this.s.dt.fnRecordsDisplay(), t.scroll = t.virtual, 1e6 < t.scroll && (t.scroll = 1e6), this.dom.force.style.height = t.scroll > this.s.heights.row ? t.scroll + "px" : this.s.heights.row + "px" } }), i.oDefaults = i.defaults = { boundaryScale: .5, displayBuffer: 9, rowHeight: "auto", serverWait: 200 }, i.version = "2.4.3", d(o).on("preInit.dt.dtscroller", function (t, s) { var o, e; "dt" === t.namespace && (t = s.oInit.scroller, o = a.defaults.scroller, t || o) && (e = d.extend({}, t, o), !1 !== t) && new i(s, e) }), d.fn.dataTable.Scroller = i, d.fn.DataTable.Scroller = i, d.fn.dataTable.Api); return t.register("scroller()", function () { return this }), t.register("scroller().rowToPixels()", function (t, s, o) { var e = this.context; if (e.length && e[0].oScroller) return e[0].oScroller.rowToPixels(t, s, o) }), t.register("scroller().pixelsToRow()", function (t, s, o) { var e = this.context; if (e.length && e[0].oScroller) return e[0].oScroller.pixelsToRow(t, s, o) }), t.register(["scroller().scrollToRow()", "scroller.toPosition()"], function (s, o) { return this.iterator("table", function (t) { t.oScroller && t.oScroller.scrollToRow(s, o) }), this }), t.register("row().scrollTo()", function (o) { var e = this; return this.iterator("row", function (t, s) { t.oScroller && (s = e.rows({ order: "applied", search: "applied" }).indexes().indexOf(s), t.oScroller.scrollToRow(s, o)) }), this }), t.register("scroller.measure()", function (s) { return this.iterator("table", function (t) { t.oScroller && t.oScroller.measure(s) }), this }), t.register("scroller.page()", function () { var t = this.context; if (t.length && t[0].oScroller) return t[0].oScroller.pageInfo() }), a });
/*! StateRestore 1.4.1
 * © SpryMedia Ltd - datatables.net/license
 */
!function (s) { var o, i; "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function (e) { return s(e, window, document) }) : "object" == typeof exports ? (o = require("jquery"), i = function (e, t) { t.fn.dataTable || require("datatables.net")(e, t) }, "undefined" == typeof window ? module.exports = function (e, t) { return e = e || window, t = t || o(e), i(e, t), s(t, 0, e.document) } : (i(window, o), module.exports = s(o, window, window.document))) : s(jQuery, window, document) }(function (y, e, g) { "use strict"; var u, m, p, a, k, s, t, c = y.fn.dataTable; function n(e, t, s, o, i, a) { if (void 0 === o && (o = void 0), void 0 === i && (i = !1), void 0 === a && (a = function () { return null }), !m || !m.versionCheck || !m.versionCheck("1.10.0")) throw new Error("StateRestore requires DataTables 1.10 or newer"); if (!m.Buttons) throw new Error("StateRestore requires Buttons"); e = new m.Api(e); this.classes = u.extend(!0, {}, n.classes), this.c = u.extend(!0, {}, n.defaults, t), this.s = { dt: e, identifier: s, isPreDefined: i, savedState: null, tableId: o && o.stateRestore ? o.stateRestore.tableId : void 0 }, this.dom = { background: u('<div class="' + this.classes.background + '"/>'), closeButton: u('<div class="' + this.classes.closeButton + '">&times;</div>'), confirmation: u('<div class="' + this.classes.confirmation + '"/>'), confirmationButton: u('<button class="' + this.classes.confirmationButton + " " + this.classes.dtButton + '">'), confirmationTitleRow: u('<div class="' + this.classes.confirmationTitleRow + '"></div>'), dtContainer: u(this.s.dt.table().container()), duplicateError: u('<span class="' + this.classes.modalError + '">' + this.s.dt.i18n("stateRestore.duplicateError", this.c.i18n.duplicateError) + "</span>"), emptyError: u('<span class="' + this.classes.modalError + '">' + this.s.dt.i18n("stateRestore.emptyError", this.c.i18n.emptyError) + "</span>"), removeContents: u('<div class="' + this.classes.confirmationText + '"><span>' + this.s.dt.i18n("stateRestore.removeConfirm", this.c.i18n.removeConfirm).replace(/%s/g, n.entityEncode(this.s.identifier)) + "</span></div>"), removeError: u('<span class="' + this.classes.modalError + '">' + this.s.dt.i18n("stateRestore.removeError", this.c.i18n.removeError) + "</span>"), removeTitle: u('<h2 class="' + this.classes.confirmationTitle + '">' + this.s.dt.i18n("stateRestore.removeTitle", this.c.i18n.removeTitle) + "</h2>"), renameContents: u('<div class="' + this.classes.confirmationText + " " + this.classes.renameModal + '"><label class="' + this.classes.confirmationMessage + '">' + this.s.dt.i18n("stateRestore.renameLabel", this.c.i18n.renameLabel).replace(/%s/g, n.entityEncode(this.s.identifier)) + "</label></div>"), renameInput: u('<input class="' + this.classes.input + '" type="text"></input>'), renameTitle: u('<h2 class="' + this.classes.confirmationTitle + '">' + this.s.dt.i18n("stateRestore.renameTitle", this.c.i18n.renameTitle) + "</h2>") }, this.save(o, a) } function r(e, t) { var o = this; if (!a || !a.versionCheck || !a.versionCheck("1.10.0")) throw new Error("StateRestore requires DataTables 1.10 or newer"); if (!a.Buttons) throw new Error("StateRestore requires Buttons"); var s, i, e = new a.Api(e); if (this.classes = p.extend(!0, {}, r.classes), void 0 === e.settings()[0]._stateRestore) return this.c = p.extend(!0, {}, r.defaults, t), this.s = { dt: e, hasColReorder: void 0 !== a.ColReorder, hasScroller: void 0 !== a.Scroller, hasSearchBuilder: void 0 !== a.SearchBuilder, hasSearchPanes: void 0 !== a.SearchPanes, hasSelect: void 0 !== a.select, states: [] }, this.s.dt.on("xhr", function (e, t, s) { s && s.stateRestore && o._addPreDefined(s.stateRestore) }), this.dom = { background: p('<div class="' + this.classes.background + '"/>'), checkboxInputRow: p('<div class="' + this.classes.formRow + '"><label class="' + this.classes.nameLabel + '">' + this.s.dt.i18n("stateRestore.creationModal.toggleLabel", this.c.i18n.creationModal.toggleLabel) + '</label><div class="dtsr-input"></div></div>'), closeButton: p('<div class="' + this.classes.closeButton + '">x</div>'), colReorderToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.colReorderToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.colReorder", this.c.i18n.creationModal.colReorder) + "</div>"), columnsSearchToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.columnsSearchToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.columns.search", this.c.i18n.creationModal.columns.search) + "</div>"), columnsVisibleToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.columnsVisibleToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.columns.visible", this.c.i18n.creationModal.columns.visible) + "</div>"), confirmation: p('<div class="' + this.classes.confirmation + '"/>'), confirmationTitleRow: p('<div class="' + this.classes.confirmationTitleRow + '"></div>'), createButtonRow: p('<div class="' + this.classes.formRow + " " + this.classes.modalFoot + '"><button class="' + this.classes.creationButton + " " + this.classes.dtButton + '">' + this.s.dt.i18n("stateRestore.creationModal.button", this.c.i18n.creationModal.button) + "</button></div>"), creation: p('<div class="' + this.classes.creation + '"/>'), creationForm: p('<div class="' + this.classes.creationForm + '"/>'), creationTitle: p('<div class="' + this.classes.creationText + '"><h2 class="' + this.classes.creationTitle + '">' + this.s.dt.i18n("stateRestore.creationModal.title", this.c.i18n.creationModal.title) + "</h2></div>"), dtContainer: p(this.s.dt.table().container()), duplicateError: p('<span class="' + this.classes.modalError + '">' + this.s.dt.i18n("stateRestore.duplicateError", this.c.i18n.duplicateError) + "</span>"), emptyError: p('<span class="' + this.classes.modalError + '">' + this.s.dt.i18n("stateRestore.emptyError", this.c.i18n.emptyError) + "</span>"), lengthToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.lengthToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.length", this.c.i18n.creationModal.length) + "</div>"), nameInputRow: p('<div class="' + this.classes.formRow + '"><label class="' + this.classes.nameLabel + '">' + this.s.dt.i18n("stateRestore.creationModal.name", this.c.i18n.creationModal.name) + '</label><div class="dtsr-input"><input class="' + this.classes.nameInput + '" type="text"></div></div>'), orderToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.orderToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.order", this.c.i18n.creationModal.order) + "</div>"), pagingToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.pagingToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.paging", this.c.i18n.creationModal.paging) + "</div>"), removeContents: p('<div class="' + this.classes.confirmationText + '"><span></span></div>'), removeTitle: p('<div class="' + this.classes.creationText + '"><h2 class="' + this.classes.creationTitle + '">' + this.s.dt.i18n("stateRestore.removeTitle", this.c.i18n.removeTitle) + "</h2></div>"), scrollerToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.scrollerToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.scroller", this.c.i18n.creationModal.scroller) + "</div>"), searchBuilderToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.searchBuilderToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.searchBuilder", this.c.i18n.creationModal.searchBuilder) + "</div>"), searchPanesToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.searchPanesToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.searchPanes", this.c.i18n.creationModal.searchPanes) + "</div>"), searchToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.searchToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.search", this.c.i18n.creationModal.search) + "</div>"), selectToggle: p('<div class="' + this.classes.checkLabel + '"><input type="checkbox" class="' + this.classes.selectToggle + " " + this.classes.checkBox + '" checked>' + this.s.dt.i18n("stateRestore.creationModal.select", this.c.i18n.creationModal.select) + "</div>") }, (e.settings()[0]._stateRestore = this)._searchForStates(), this._addPreDefined(this.c.preDefined), i = { action: "load" }, "function" == typeof this.c.ajax ? s = function () { "function" == typeof o.c.ajax && o.c.ajax.call(o.s.dt, i, function (e) { return o._addPreDefined(e) }) } : "string" == typeof this.c.ajax && (s = function () { p.ajax({ data: i, success: function (e) { o._addPreDefined(e) }, type: "POST", url: o.c.ajax }) }), "function" == typeof s && (this.s.dt.settings()[0]._bInitComplete ? s() : this.s.dt.one("preInit.dtsr", function () { s() })), this.s.dt.on("destroy.dtsr", function () { o.destroy() }), this.s.dt.on("draw.dtsr buttons-action.dtsr", function () { return o.findActive() }), this } function o(e, t) { l(e, new c.StateRestoreCollection(e, t.config)) } function l(e, t) { var s = e.stateRestore.states(), o = e.button("SaveStateRestore:name"), i = []; if (o[0]) for (var a = o.index().split("-"), i = o[0].inst.c.buttons, n = 0; n < a.length; n++) { if (!i[a[n]].buttons) { i = []; break } i = i[a[n]].buttons } var r = e.settings()[0]._stateRestore.c; for (n = 0; n < i.length; n++)"stateRestore" === i[n].extend && (i.splice(n, 1), n--); if (r._createInSaved && i.push("createState"), void 0 === s || 0 === s.length) i.push('<span class="' + t.classes.emptyStates + '">' + e.i18n("stateRestore.emptyStates", t.c.i18n.emptyStates) + "</span>"); else for (var c = 0, l = s; c < l.length; c++) { var d = l[c], h = r.splitSecondaries.slice(); h.includes("updateState") && !r.save && h.splice(h.indexOf("updateState"), 1), !h.includes("renameState") || r.save && r.rename || h.splice(h.indexOf("renameState"), 1), h.includes("removeState") && !r.remove && h.splice(h.indexOf("removeState"), 1), i.push({ _stateRestore: d, attr: { title: d.s.identifier }, config: { split: h }, extend: "stateRestore", text: k.entityEncode(d.s.identifier), popoverTitle: k.entityEncode(d.s.identifier) }) } e.button("SaveStateRestore:name").collectionRebuild(i); for (var u = 0, m = e.buttons(); u < m.length; u++) { var v = m[u]; y(v.node).hasClass("dtsr-removeAllStates") && (0 === s.length ? e.button(v.node).disable() : e.button(v.node).enable()) } } return n.prototype.remove = function (e) { var t, s, o, i, a = this; return void 0 === e && (e = !1), !!this.c.remove && (o = { action: "remove", stateRestore: ((t = {})[this.s.identifier] = this.s.savedState, t) }, i = function () { a.dom.confirmation.trigger("dtsr-remove"), u(a.s.dt.table().node()).trigger("stateRestore-change"), a.dom.background.click(), a.dom.confirmation.remove(), u(g).unbind("keyup", function (e) { return a._keyupFunction(e) }), a.dom.confirmationButton.off("click") }, this.c.ajax ? "string" == typeof this.c.ajax && this.s.dt.settings()[0]._bInitComplete ? s = function () { return u.ajax({ data: o, success: i, type: "POST", url: a.c.ajax }), !0 } : "function" == typeof this.c.ajax && (s = function () { return "function" == typeof a.c.ajax && a.c.ajax.call(a.s.dt, o, i), !0 }) : s = function () { try { localStorage.removeItem("DataTables_stateRestore_" + a.s.identifier + "_" + location.pathname + (a.s.tableId ? "_" + a.s.tableId : "")), i() } catch (e) { return a.dom.confirmation.children("." + a.classes.modalError).remove(), a.dom.confirmation.append(a.dom.removeError), "remove" } return !0 }, e ? (this.dom.confirmation.appendTo(this.dom.dtContainer), u(this.s.dt.table().node()).trigger("dtsr-modal-inserted"), s(), this.dom.confirmation.remove()) : this._newModal(this.dom.removeTitle, this.s.dt.i18n("stateRestore.removeSubmit", this.c.i18n.removeSubmit), s, this.dom.removeContents), !0) }, n.prototype.compare = function (e) { if (this.c.saveState.order || (e.order = void 0), this.c.saveState.search || (e.search = void 0), this.c.saveState.columns && e.columns) for (var t = 0, s = e.columns.length; t < s; t++)"boolean" == typeof this.c.saveState.columns || this.c.saveState.columns.visible || (e.columns[t].visible = void 0), "boolean" == typeof this.c.saveState.columns || this.c.saveState.columns.search || (e.columns[t].search = void 0); else this.c.saveState.columns || (e.columns = void 0); this.c.saveState.paging || (e.page = void 0), this.c.saveState.searchBuilder || (e.searchBuilder = void 0), this.c.saveState.searchPanes || (e.searchPanes = void 0), this.c.saveState.select || (e.select = void 0), this.c.saveState.colReorder || (e.ColReorder = void 0), this.c.saveState.scroller || (e.scroller = void 0) !== m.Scroller && (e.start = 0), this.c.saveState.paging || (e.start = 0), this.c.saveState.length || (e.length = void 0), delete e.time; var o = this.s.savedState; return delete o.time, delete o.c, delete o.stateRestore, this._deepCompare(e, o) }, n.prototype.destroy = function () { u.each(this.dom, function (e, t) { t.off().remove() }) }, n.prototype.load = function () { function e() { o.s.dt.one("preDraw", function (e, s) { setTimeout(function () { var e = s._iDisplayStart / s._iDisplayLength, t = i.start / i.length; 0 <= e && 0 <= t && e != t && o.s.dt.page(t).draw(!1) }, 50) }), o.s.dt.draw(!1) } var o = this, i = this.s.savedState, t = this.s.dt.settings()[0]; i.time = +new Date, t.oLoadedState = u.extend(!0, {}, i), u("div.dt-button-background").click(); return c.versionCheck("2") ? (this.s.dt.state(i), e()) : c.ext.oApi._fnImplementState(t, i, e), i }, n.prototype.rename = function (s, o) { var i = this; if (void 0 === s && (s = null), this.c.rename) { var e = function () { if (null === s) { var e = u("input." + i.classes.input.replace(/ /g, ".")).val(); if (0 === e.length) return i.dom.confirmation.children("." + i.classes.modalError).remove(), i.dom.confirmation.append(i.dom.emptyError), "empty"; if (o.includes(e)) return i.dom.confirmation.children("." + i.classes.modalError).remove(), i.dom.confirmation.append(i.dom.duplicateError), "duplicate"; s = e } function t() { i.s.identifier = s, i.save(i.s.savedState, function () { return null }, !1), i.dom.removeContents = u('<div class="' + i.classes.confirmationText + '"><span>' + i.s.dt.i18n("stateRestore.removeConfirm", i.c.i18n.removeConfirm).replace(/%s/g, i.s.identifier) + "</span></div>"), i.dom.confirmation.trigger("dtsr-rename"), i.dom.background.click(), i.dom.confirmation.remove(), u(g).unbind("keyup", function (e) { return i._keyupFunction(e) }), i.dom.confirmationButton.off("click") } e = { action: "rename", stateRestore: ((e = {})[i.s.identifier] = s, e) }; if (i.c.ajax) "string" == typeof i.c.ajax && i.s.dt.settings()[0]._bInitComplete ? u.ajax({ data: e, success: t, type: "POST", url: i.c.ajax }) : "function" == typeof i.c.ajax && i.c.ajax.call(i.s.dt, e, t); else try { localStorage.removeItem("DataTables_stateRestore_" + i.s.identifier + "_" + location.pathname + (i.s.tableId ? "_" + i.s.tableId : "")), t() } catch (e) { return i.dom.confirmation.children("." + i.classes.modalError).remove(), i.dom.confirmation.append(i.dom.removeError), !1 } return !0 }; if (null !== s) { if (o.includes(s)) throw new Error(this.s.dt.i18n("stateRestore.duplicateError", this.c.i18n.duplicateError)); if (0 === s.length) throw new Error(this.s.dt.i18n("stateRestore.emptyError", this.c.i18n.emptyError)); this.dom.confirmation.appendTo(this.dom.dtContainer), u(this.s.dt.table().node()).trigger("dtsr-modal-inserted"), e(), this.dom.confirmation.remove() } else this.dom.renameInput.val(this.s.identifier), this.dom.renameContents.append(this.dom.renameInput), this._newModal(this.dom.renameTitle, this.s.dt.i18n("stateRestore.renameButton", this.c.i18n.renameButton), e, this.dom.renameContents) } }, n.prototype.save = function (e, t, s) { var o, i, a, n = this; if (void 0 === s && (s = !0), this.c.save) { if (this.s.dt.state.save(), void 0 === e) o = this.s.dt.state(); else { if ("object" != typeof e) return; o = e } if (o.stateRestore ? (o.stateRestore.isPreDefined = this.s.isPreDefined, o.stateRestore.state = this.s.identifier, o.stateRestore.tableId = this.s.tableId) : o.stateRestore = { isPreDefined: this.s.isPreDefined, state: this.s.identifier, tableId: this.s.tableId }, this.s.savedState = o, this.c.saveState.order || (this.s.savedState.order = void 0), this.c.saveState.search || (this.s.savedState.search = void 0), this.c.saveState.columns && this.s.savedState.columns) for (var r = 0, c = this.s.savedState.columns.length; r < c; r++)"boolean" == typeof this.c.saveState.columns || this.c.saveState.columns.visible || (this.s.savedState.columns[r].visible = void 0), "boolean" == typeof this.c.saveState.columns || this.c.saveState.columns.search || (this.s.savedState.columns[r].search = void 0); else this.c.saveState.columns || (this.s.savedState.columns = void 0); if (this.c.saveState.searchBuilder || (this.s.savedState.searchBuilder = void 0), this.c.saveState.searchPanes || (this.s.savedState.searchPanes = void 0), this.c.saveState.select || (this.s.savedState.select = void 0), this.c.saveState.colReorder || (this.s.savedState.ColReorder = void 0), this.c.saveState.scroller || (this.s.savedState.scroller = void 0) !== m.Scroller && (this.s.savedState.start = 0), this.c.saveState.paging || (this.s.savedState.start = 0), this.c.saveState.length || (this.s.savedState.length = void 0), this.s.savedState.c = this.c, this.s.savedState.c.splitSecondaries.length) for (var l = 0, d = this.s.savedState.c.splitSecondaries; l < d.length; l++) { var h = d[l]; h.parent && (h.parent = void 0) } this.s.isPreDefined ? t && t.call(this) : (i = { action: "save", stateRestore: ((e = {})[this.s.identifier] = this.s.savedState, e) }, a = function () { t && t.call(n), n.dom.confirmation.trigger("dtsr-save"), u(n.s.dt.table().node()).trigger("stateRestore-change") }, this.c.ajax ? "string" == typeof this.c.ajax && s ? this.s.dt.settings()[0]._bInitComplete ? u.ajax({ data: i, success: a, type: "POST", url: this.c.ajax }) : this.s.dt.one("init", function () { u.ajax({ data: i, success: a, type: "POST", url: n.c.ajax }) }) : "function" == typeof this.c.ajax && s && this.c.ajax.call(this.s.dt, i, a) : (localStorage.setItem("DataTables_stateRestore_" + this.s.identifier + "_" + location.pathname + (this.s.tableId ? "_" + this.s.tableId : ""), JSON.stringify(this.s.savedState)), a())) } else t && t.call(this) }, n.entityEncode = function (e) { return "string" == typeof e ? e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : e }, n.prototype._deepCompare = function (e, t) { var s, o, i = [e, t], a = [Object.keys(e).sort(), Object.keys(t).sort()]; for (a[0].includes("scroller") && (s = a[0].indexOf("start")) && a[0].splice(s, 1), a[1].includes("scroller") && (s = a[1].indexOf("start")) && a[1].splice(s, 1), o = 0; o < a[0].length; o++)0 !== a[0][o].indexOf("_") && "baseRowTop" !== a[0][o] && "baseScrollTop" !== a[0][o] && "scrollTop" !== a[0][o] && (this.c.saveState.paging || "page" !== a[0][o]) || (a[0].splice(o, 1), o--); for (o = 0; o < a[1].length; o++)0 !== a[1][o].indexOf("_") && "baseRowTop" !== a[1][o] && "baseScrollTop" !== a[1][o] && "scrollTop" !== a[1][o] && (this.c.saveState.paging || "page" !== a[0][o]) || (a[1].splice(o, 1), o--); if (0 === a[0].length && 0 < a[1].length || 0 === a[1].length && 0 < a[0].length) return !1; for (o = 0; o < a[0].length; o++)a[1].includes(a[0][o]) || (a[0].splice(o, 1), o--); for (o = 0; o < a[1].length; o++)a[0].includes(a[1][o]) || (a[1].splice(o, 1), o--); for (o = 0; o < a[0].length; o++) { if (a[0][o] !== a[1][o] || typeof i[0][a[0][o]] != typeof i[1][a[1][o]]) return !1; if ("object" == typeof i[0][a[0][o]]) { if (!this._deepCompare(i[0][a[0][o]], i[1][a[1][o]])) return !1 } else if ("number" == typeof i[0][a[0][o]] && "number" == typeof i[1][a[1][o]]) { if (Math.round(i[0][a[0][o]]) !== Math.round(i[1][a[1][o]])) return !1 } else if (i[0][a[0][o]] !== i[1][a[1][o]]) return !1 } return !0 }, n.prototype._keyupFunction = function (e) { "Enter" === e.key ? this.dom.confirmationButton.click() : "Escape" === e.key && u("div." + this.classes.background.replace(/ /g, ".")).click() }, n.prototype._newModal = function (e, t, s, o) { var i = this, e = (this.dom.background.appendTo(this.dom.dtContainer), this.dom.confirmationTitleRow.empty().append(e), this.dom.confirmationButton.html(t), this.dom.confirmation.empty().append(this.dom.confirmationTitleRow).append(o).append(u('<div class="' + this.classes.confirmationButtons + '"></div>').append(this.dom.confirmationButton)).appendTo(this.dom.dtContainer), u(this.s.dt.table().node()).trigger("dtsr-modal-inserted"), o.children("input")), a = ((0 < e.length ? u(e[0]) : this.dom.confirmationButton).focus(), u("div." + this.classes.background.replace(/ /g, "."))); this.c.modalCloseButton && (this.dom.confirmation.append(this.dom.closeButton), this.dom.closeButton.on("click", function () { return a.click() })), this.dom.confirmationButton.on("click", function () { return s() }), this.dom.confirmation.on("click", function (e) { e.stopPropagation() }), a.one("click", function () { i.dom.background.remove(), i.dom.confirmation.remove(), u(g).unbind("keyup", function (e) { return i._keyupFunction(e) }) }), u(g).on("keyup", function (e) { return i._keyupFunction(e) }) }, n.version = "1.4.1", n.classes = { background: "dtsr-background", closeButton: "dtsr-popover-close", confirmation: "dtsr-confirmation", confirmationButton: "dtsr-confirmation-button", confirmationButtons: "dtsr-confirmation-buttons", confirmationMessage: "dtsr-confirmation-message dtsr-name-label", confirmationText: "dtsr-confirmation-text", confirmationTitle: "dtsr-confirmation-title", confirmationTitleRow: "dtsr-confirmation-title-row", dtButton: "dt-button", input: "dtsr-input", modalError: "dtsr-modal-error", renameModal: "dtsr-rename-modal" }, n.defaults = { _createInSaved: !1, ajax: !1, create: !0, creationModal: !1, i18n: { creationModal: { button: "Create", colReorder: "Column Order:", columns: { search: "Column Search:", visible: "Column Visibility:" }, length: "Page Length:", name: "Name:", order: "Sorting:", paging: "Paging:", scroller: "Scroll Position:", search: "Search:", searchBuilder: "SearchBuilder:", searchPanes: "SearchPanes:", select: "Select:", title: "Create New State", toggleLabel: "Includes:" }, duplicateError: "A state with this name already exists.", emptyError: "Name cannot be empty.", emptyStates: "No saved states", removeConfirm: "Are you sure you want to remove %s?", removeError: "Failed to remove state.", removeJoiner: " and ", removeSubmit: "Remove", removeTitle: "Remove State", renameButton: "Rename", renameLabel: "New Name for %s:", renameTitle: "Rename State" }, modalCloseButton: !0, remove: !0, rename: !0, save: !0, saveState: { colReorder: !0, columns: { search: !0, visible: !0 }, length: !0, order: !0, paging: !0, scroller: !0, search: !0, searchBuilder: !0, searchPanes: !0, select: !0 }, splitSecondaries: ["updateState", "renameState", "removeState"], toggle: { colReorder: !1, columns: { search: !1, visible: !1 }, length: !1, order: !1, paging: !1, scroller: !1, search: !1, searchBuilder: !1, searchPanes: !1, select: !1 } }, k = n, r.prototype.addState = function (e, u, m) { var v = this; if (this.c.create && this.c.save) { var t = function (e, t) { if (0 === e.length) return "empty"; if (u.includes(e)) return "duplicate"; v.s.dt.state.save(); var s = v, o = v.s.dt.state(); if (o.stateRestore = { isPredefined: !1, state: e, tableId: v.s.dt.table().node().id }, t.saveState) { for (var i = v.c.saveState, a = 0, n = Object.keys(t.saveState); a < n.length; a++) { var r = n[a]; if ("object" == typeof t.saveState[r]) for (var c = 0, l = Object.keys(t.saveState[r]); c < l.length; c++) { var d = l[c]; t.saveState[r][d] || (i[r][d] = !1) } else t.saveState[r] || (i[r] = !1) } v.c.saveState = i } var h = new k(v.s.dt.settings()[0], p.extend(!0, {}, v.c, m), e, o, !1, function () { s.s.states.push(this), s._collectionRebuild() }); return p(v.s.dt.table().node()).on("dtsr-modal-inserted", function () { h.dom.confirmation.one("dtsr-remove", function () { return v._removeCallback(h.s.identifier) }), h.dom.confirmation.one("dtsr-rename", function () { return v._collectionRebuild() }), h.dom.confirmation.one("dtsr-save", function () { return v._collectionRebuild() }) }), !0 }; if (null !== this.getState(e)) throw new Error(this.s.dt.i18n("stateRestore.duplicateError", this.c.i18n.duplicateError)); if (this.c.creationModal || void 0 !== m && m.creationModal) this._creationModal(t, e, m); else { t = t(e, {}); if ("empty" === t) throw new Error(this.s.dt.i18n("stateRestore.emptyError", this.c.i18n.emptyError)); if ("duplicate" === t) throw new Error(this.s.dt.i18n("stateRestore.duplicateError", this.c.i18n.duplicateError)) } } }, r.prototype.removeAll = function (e) { var t, s; 0 !== this.s.states.length && (s = (t = this.s.states.map(function (e) { return e.s.identifier }))[0], 1 < t.length && (s = t.slice(0, -1).join(", ") + this.s.dt.i18n("stateRestore.removeJoiner", this.c.i18n.removeJoiner) + t.slice(-1)), p(this.dom.removeContents.children("span")).html(this.s.dt.i18n("stateRestore.removeConfirm", this.c.i18n.removeConfirm).replace(/%s/g, s)), this._newModal(this.dom.removeTitle, this.s.dt.i18n("stateRestore.removeSubmit", this.c.i18n.removeSubmit), e, this.dom.removeContents)) }, r.prototype.destroy = function () { for (var e = 0, t = this.s.states; e < t.length; e++)t[e].destroy(); p.each(this.dom, function (e, t) { t.off().remove() }), this.s.states = [], this.s.dt.off(".dtsr"), p(this.s.dt.table().node()).off(".dtsr") }, r.prototype.findActive = function () { this.s.dt.state.save(); for (var e = this.s.dt.state(), t = this.s.dt.buttons().nodes(), s = 0, o = t; s < o.length; s++)d = o[s], (p(d).hasClass("dtsr-state") || p(d).children().hasClass("dtsr-state")) && this.s.dt.button(d).active(!1); for (var i = [], a = 0, n = this.s.states; a < n.length; a++) { var r = n[a]; if (r.compare(e)) { i.push({ data: r.s.savedState, name: r.s.identifier }); for (var c = 0, l = t; c < l.length; c++) { var d = l[c], h = this.s.dt.button(d); if (h.text() === r.s.identifier) { h.active(!0); break } } } } return i }, r.prototype.getState = function (e) { for (var t = 0, s = this.s.states; t < s.length; t++) { var o = s[t]; if (o.s.identifier === e) return o } return null }, r.prototype.getStates = function (e) { if (void 0 === e) return this.s.states; for (var t = [], s = 0, o = e; s < o.length; s++) { for (var i = o[s], a = !1, n = 0, r = this.s.states; n < r.length; n++) { var c = r[n]; if (i === c.s.identifier) { t.push(c), a = !0; break } } a || t.push(void 0) } return t }, r.prototype._addPreDefined = function (a) { for (var n = this, e = Object.keys(a).sort(function (e, t) { return t < e ? 1 : e < t ? -1 : 0 }), r = this, t = 0, s = e; t < s.length; t++)!function (e) { for (var t = 0; t < r.s.states.length; t++)r.s.states[t].s.identifier === e && r.s.states.splice(t, 1); var s = r, o = a[e], i = new k(r.s.dt, p.extend(!0, {}, r.c, void 0 !== o.c ? { saveState: o.c.saveState } : void 0, !0), e, o, !0, function () { s.s.states.push(this), s._collectionRebuild() }); i.s.savedState = o, p(r.s.dt.table().node()).on("dtsr-modal-inserted", function () { i.dom.confirmation.one("dtsr-remove", function () { return n._removeCallback(i.s.identifier) }), i.dom.confirmation.one("dtsr-rename", function () { return n._collectionRebuild() }), i.dom.confirmation.one("dtsr-save", function () { return n._collectionRebuild() }) }) }(s[t]) }, r.prototype._collectionRebuild = function () { var e = this.s.dt.button("SaveStateRestore:name"), t = []; if (e[0]) for (var s = e.index().split("-"), t = e[0].inst.c.buttons, o = 0; o < s.length; o++) { if (!t[s[o]].buttons) { t = []; break } t = t[s[o]].buttons } for (o = 0; o < t.length; o++)"stateRestore" === t[o].extend && (t.splice(o, 1), o--); this.c._createInSaved && t.push("createState"); var i = '<span class="' + this.classes.emptyStates + '">' + this.s.dt.i18n("stateRestore.emptyStates", this.c.i18n.emptyStates) + "</span>"; if (0 === this.s.states.length) t.includes(i) || t.push(i); else { for (; t.includes(i);)t.splice(t.indexOf(i), 1); this.s.states = this.s.states.sort(function (e, t) { e = e.s.identifier, t = t.s.identifier; return t < e ? 1 : e < t ? -1 : 0 }); for (var a = 0, n = this.s.states; a < n.length; a++) { var r = n[a], c = this.c.splitSecondaries.slice(); !c.includes("updateState") || this.c.save && r.c.save || c.splice(c.indexOf("updateState"), 1), !c.includes("renameState") || this.c.save && r.c.save && this.c.rename && r.c.rename || c.splice(c.indexOf("renameState"), 1), !c.includes("removeState") || this.c.remove && r.c.remove || c.splice(c.indexOf("removeState"), 1), t.push({ _stateRestore: r, attr: { title: r.s.identifier }, config: { split: c }, extend: "stateRestore", text: k.entityEncode(r.s.identifier), popoverTitle: k.entityEncode(r.s.identifier) }) } } e.collectionRebuild(t); for (var l = 0, d = this.s.dt.buttons(); l < d.length; l++) { var h = d[l]; p(h.node).hasClass("dtsr-removeAllStates") && (0 === this.s.states.length ? this.s.dt.button(h.node).disable() : this.s.dt.button(h.node).enable()) } }, r.prototype._creationModal = function (t, e, s) { for (var o, i = this, e = (this.dom.creation.empty(), this.dom.creationForm.empty(), this.dom.nameInputRow.find("input").val(e), this.dom.creationForm.append(this.dom.nameInputRow), this.s.dt.settings()[0].oInit), a = [], n = void 0 !== s && void 0 !== s.toggle, r = (((!n || void 0 === s.toggle.order) && this.c.toggle.order || n && s.toggle.order) && this.c.saveState.order && (void 0 === e.ordering || e.ordering) && a.push(this.dom.orderToggle), ((!n || void 0 === s.toggle.search) && this.c.toggle.search || n && s.toggle.search) && this.c.saveState.search && (void 0 === e.searching || e.searching) && a.push(this.dom.searchToggle), ((!n || void 0 === s.toggle.paging) && this.c.toggle.paging || n && s.toggle.paging) && this.c.saveState.paging && (void 0 === e.paging || e.paging) && a.push(this.dom.pagingToggle), ((!n || void 0 === s.toggle.length) && this.c.toggle.length || n && s.toggle.length) && this.c.saveState.length && (void 0 === e.length || e.length) && a.push(this.dom.lengthToggle), this.s.hasColReorder && ((!n || void 0 === s.toggle.colReorder) && this.c.toggle.colReorder || n && s.toggle.colReorder) && this.c.saveState.colReorder && a.push(this.dom.colReorderToggle), this.s.hasScroller && ((!n || void 0 === s.toggle.scroller) && this.c.toggle.scroller || n && s.toggle.scroller) && this.c.saveState.scroller && a.push(this.dom.scrollerToggle), this.s.hasSearchBuilder && ((!n || void 0 === s.toggle.searchBuilder) && this.c.toggle.searchBuilder || n && s.toggle.searchBuilder) && this.c.saveState.searchBuilder && a.push(this.dom.searchBuilderToggle), this.s.hasSearchPanes && ((!n || void 0 === s.toggle.searchPanes) && this.c.toggle.searchPanes || n && s.toggle.searchPanes) && this.c.saveState.searchPanes && a.push(this.dom.searchPanesToggle), this.s.hasSelect && ((!n || void 0 === s.toggle.select) && this.c.toggle.select || n && s.toggle.select) && this.c.saveState.select && a.push(this.dom.selectToggle), "boolean" == typeof this.c.toggle.columns && ((!n || void 0 === s.toggle.order) && this.c.toggle.columns || n && s.toggle.order) && this.c.saveState.columns ? (a.push(this.dom.columnsSearchToggle), a.push(this.dom.columnsVisibleToggle)) : (n && void 0 !== s.toggle.columns || "boolean" == typeof this.c.toggle.columns) && "boolean" == typeof s.toggle.order || ("boolean" != typeof this.c.saveState.columns && this.c.saveState.columns ? ((n && void 0 !== s.toggle.columns && "boolean" != typeof s.toggle.columns && s.toggle.columns.search || (!n || void 0 === s.toggle.columns || "boolean" != typeof s.toggle.columns && void 0 === s.toggle.columns.search) && "boolean" != typeof this.c.toggle.columns && this.c.toggle.columns.search) && this.c.saveState.columns.search && a.push(this.dom.columnsSearchToggle), (n && void 0 !== s.toggle.columns && "boolean" != typeof s.toggle.columns && s.toggle.columns.visible || (!n || void 0 === s.toggle.columns || "boolean" != typeof s.toggle.columns && void 0 === s.toggle.columns.visible) && "boolean" != typeof this.c.toggle.columns && this.c.toggle.columns.visible) && this.c.saveState.columns.visible && a.push(this.dom.columnsVisibleToggle)) : this.c.saveState.columns && (a.push(this.dom.columnsSearchToggle), a.push(this.dom.columnsVisibleToggle))), a.sort(function (e, t) { e = e.text(), t = t.text(); return e < t ? -1 : t < e ? 1 : 0 }), this.dom.checkboxInputRow.appendTo(this.dom.creationForm).find("div.dtsr-input").empty()), c = 0, l = a; c < l.length; c++)o = l[c], r.append(o); this.dom.background.appendTo(this.dom.dtContainer), this.dom.creation.append(this.dom.creationTitle).append(this.dom.creationForm).append(this.dom.createButtonRow).appendTo(this.dom.dtContainer), p(this.s.dt.table().node()).trigger("dtsr-modal-inserted"); for (var d = 0, h = a; d < h.length; d++)p((o = h[d]).children("label:last-child")).on("click", function () { o.children("input").prop("checked", !o.children("input").prop("checked")) }); function u(e) { "Enter" === e.key ? m.click() : "Escape" === e.key && v.click() } var m = p("button." + this.classes.creationButton.replace(/ /g, ".")), e = this.dom.creationForm.find("input"), v = ((0 < e.length ? p(e[0]) : m).focus(), p("div." + this.classes.background.replace(/ /g, "."))); this.c.modalCloseButton && (this.dom.creation.append(this.dom.closeButton), this.dom.closeButton.on("click", function () { return v.click() })), m.on("click", function () { var e = { colReorder: i.dom.colReorderToggle.find("input").is(":checked"), columns: { search: i.dom.columnsSearchToggle.find("input").is(":checked"), visible: i.dom.columnsVisibleToggle.find("input").is(":checked") }, length: i.dom.lengthToggle.find("input").is(":checked"), order: i.dom.orderToggle.find("input").is(":checked"), paging: i.dom.pagingToggle.find("input").is(":checked"), scroller: i.dom.scrollerToggle.find("input").is(":checked"), search: i.dom.searchToggle.find("input").is(":checked"), searchBuilder: i.dom.searchBuilderToggle.find("input").is(":checked"), searchPanes: i.dom.searchPanesToggle.find("input").is(":checked"), select: i.dom.selectToggle.find("input").is(":checked") }, e = t(p("input." + i.classes.nameInput.replace(/ /g, ".")).val(), { saveState: e }); !0 === e ? (i.dom.background.remove(), i.dom.creation.remove(), p(g).unbind("keyup", u)) : (i.dom.creation.children("." + i.classes.modalError).remove(), i.dom.creation.append(i.dom[e + "Error"])) }), v.one("click", function () { i.dom.background.remove(), i.dom.creation.remove(), p(g).unbind("keyup", u), i._collectionRebuild() }), p(g).on("keyup", u), this.s.dt.state.save() }, r.prototype._removeCallback = function (e) { for (var t = 0; t < this.s.states.length; t++)this.s.states[t].s.identifier === e && (this.s.states.splice(t, 1), t--); return this._collectionRebuild(), !0 }, r.prototype._newModal = function (e, t, s, o) { function i(e) { "Enter" === e.key ? n.click() : "Escape" === e.key && r.click() } var a = this, n = (this.dom.background.appendTo(this.dom.dtContainer), this.dom.confirmationTitleRow.empty().append(e), p('<button class="' + this.classes.confirmationButton + " " + this.classes.dtButton + '">' + t + "</button>")), e = (this.dom.confirmation.empty().append(this.dom.confirmationTitleRow).append(o).append(p('<div class="' + this.classes.confirmationButtons + '"></div>').append(n)).appendTo(this.dom.dtContainer), p(this.s.dt.table().node()).trigger("dtsr-modal-inserted"), o.children("input")), r = ((0 < e.length ? p(e[0]) : n).focus(), p("div." + this.classes.background.replace(/ /g, "."))); n.on("click", function () { var e = s(!0); !0 === e ? (a.dom.background.remove(), a.dom.confirmation.remove(), p(g).unbind("keyup", i), n.off("click")) : (a.dom.confirmation.children("." + a.classes.modalError).remove(), a.dom.confirmation.append(a.dom[e + "Error"])) }), this.dom.confirmation.on("click", function (e) { e.stopPropagation() }), r.one("click", function () { a.dom.background.remove(), a.dom.confirmation.remove(), p(g).unbind("keyup", i) }), p(g).on("keyup", i) }, r.prototype._searchForStates = function () { for (var i = this, e = Object.keys(localStorage), a = this, t = 0, s = e; t < s.length; t++)!function (e) { if (e.match(new RegExp("^DataTables_stateRestore_.*_" + location.pathname + "$")) || e.match(new RegExp("^DataTables_stateRestore_.*_" + location.pathname + "_" + a.s.dt.table().node().id + "$"))) { var t = JSON.parse(localStorage.getItem(e)); if (t.stateRestore.isPreDefined || t.stateRestore.tableId && t.stateRestore.tableId !== a.s.dt.table().node().id) return; var s = a, o = new k(a.s.dt, p.extend(!0, {}, a.c, { saveState: t.c.saveState }), t.stateRestore.state, t, !1, function () { this.s.savedState = t, s.s.states.push(this), s._collectionRebuild() }); p(a.s.dt.table().node()).on("dtsr-modal-inserted", function () { o.dom.confirmation.one("dtsr-remove", function () { return i._removeCallback(o.s.identifier) }), o.dom.confirmation.one("dtsr-rename", function () { return i._collectionRebuild() }), o.dom.confirmation.one("dtsr-save", function () { return i._collectionRebuild() }) }) } }(s[t]) }, r.version = "1.0.0", r.classes = { background: "dtsr-background", checkBox: "dtsr-check-box", checkLabel: "dtsr-check-label", checkRow: "dtsr-check-row", closeButton: "dtsr-popover-close", colReorderToggle: "dtsr-colReorder-toggle", columnsSearchToggle: "dtsr-columns-search-toggle", columnsVisibleToggle: "dtsr-columns-visible-toggle", confirmation: "dtsr-confirmation", confirmationButton: "dtsr-confirmation-button", confirmationButtons: "dtsr-confirmation-buttons", confirmationMessage: "dtsr-confirmation-message dtsr-name-label", confirmationText: "dtsr-confirmation-text", confirmationTitle: "dtsr-confirmation-title", confirmationTitleRow: "dtsr-confirmation-title-row", creation: "dtsr-creation", creationButton: "dtsr-creation-button", creationForm: "dtsr-creation-form", creationText: "dtsr-creation-text", creationTitle: "dtsr-creation-title", dtButton: "dt-button", emptyStates: "dtsr-emptyStates", formRow: "dtsr-form-row", leftSide: "dtsr-left", lengthToggle: "dtsr-length-toggle", modalError: "dtsr-modal-error", modalFoot: "dtsr-modal-foot", nameInput: "dtsr-name-input", nameLabel: "dtsr-name-label", orderToggle: "dtsr-order-toggle", pagingToggle: "dtsr-paging-toggle", rightSide: "dtsr-right", scrollerToggle: "dtsr-scroller-toggle", searchBuilderToggle: "dtsr-searchBuilder-toggle", searchPanesToggle: "dtsr-searchPanes-toggle", searchToggle: "dtsr-search-toggle", selectToggle: "dtsr-select-toggle", toggleLabel: "dtsr-toggle-title" }, r.defaults = { _createInSaved: !1, ajax: !1, create: !0, creationModal: !1, i18n: { creationModal: { button: "Create", colReorder: "Column Order", columns: { search: "Column Search", visible: "Column Visibility" }, length: "Page Length", name: "Name:", order: "Sorting", paging: "Paging", scroller: "Scroll Position", search: "Search", searchBuilder: "SearchBuilder", searchPanes: "SearchPanes", select: "Select", title: "Create New State", toggleLabel: "Include:" }, duplicateError: "A state with this name already exists.", emptyError: "Name cannot be empty.", emptyStates: "No saved states", removeConfirm: "Are you sure you want to remove %s?", removeError: "Failed to remove state.", removeJoiner: " and ", removeSubmit: "Remove", removeTitle: "Remove State", renameButton: "Rename", renameLabel: "New Name for %s:", renameTitle: "Rename State" }, modalCloseButton: !0, preDefined: {}, remove: !0, rename: !0, save: !0, saveState: { colReorder: !0, columns: { search: !0, visible: !0 }, length: !0, order: !0, paging: !0, scroller: !0, search: !0, searchBuilder: !0, searchPanes: !0, select: !0 }, splitSecondaries: ["updateState", "renameState", "removeState"], toggle: { colReorder: !1, columns: { search: !1, visible: !1 }, length: !1, order: !1, paging: !1, scroller: !1, search: !1, searchBuilder: !1, searchPanes: !1, select: !1 } }, s = r, m = (u = y).fn.dataTable, a = (p = y).fn.dataTable, y.fn.dataTable.StateRestore = k, y.fn.DataTable.StateRestore = k, y.fn.dataTable.StateRestoreCollection = s, y.fn.DataTable.StateRestoreCollection = s, (t = c.Api.register)("stateRestore()", function () { return this }), t("stateRestore.state()", function (e) { var t, s = this.context[0]; return s._stateRestore || l(t = c.Api(s), new c.StateRestoreCollection(t, {})), this[0] = s._stateRestore.getState(e), this }), t("stateRestore.state.add()", function (e, t) { var s, o = this.context[0]; if (o._stateRestore || l(s = c.Api(o), new c.StateRestoreCollection(s, {})), !o._stateRestore.c.create) return this; if (o._stateRestore.addState) { for (var i = [], a = 0, n = o._stateRestore.s.states; a < n.length; a++) { var r = n[a]; i.push(r.s.identifier) } return o._stateRestore.addState(e, i, t), this } }), t("stateRestore.states()", function (e) { var t, s = this.context[0]; return s._stateRestore || l(t = c.Api(s), new c.StateRestoreCollection(t, {})), this.length = 0, this.push.apply(this, s._stateRestore.getStates(e)), this }), t("stateRestore.state().save()", function () { var e = this[0]; return e.c.save && e.save(), this }), t("stateRestore.state().rename()", function (e) { var t = this.context[0], s = this[0]; if (s.c.save) { for (var o = [], i = 0, a = t._stateRestore.s.states; i < a.length; i++) { var n = a[i]; o.push(n.s.identifier) } s.rename(e, o) } return this }), t("stateRestore.state().load()", function () { return this[0].load(), this }), t("stateRestore.state().remove()", function (e) { var t = this[0]; return t.c.remove && t.remove(e), this }), t("stateRestore.states().remove()", function (e) { function t(e) { for (var t = !0, s = i.toArray(); 0 < s.length;) { var o = s[0]; if (void 0 === o || !o.c.remove) break; o = o.remove(e); !0 !== o ? t = o : s.splice(0, 1) } return t } var i = this; return this.context[0]._stateRestore && this.context[0]._stateRestore.c.remove && (e ? t(e) : this.context[0]._stateRestore.removeAll(t)), this }), t("stateRestore.activeStates()", function () { var e, t = this.context[0]; return this.length = 0, t._stateRestore || l(e = c.Api(t), new c.StateRestoreCollection(e, {})), t._stateRestore && this.push.apply(this, t._stateRestore.findActive()), this }), c.ext.buttons.stateRestore = { action: function (e, t, s, o) { o._stateRestore.load(), s.blur() }, className: "dtsr-state", config: { split: ["updateState", "renameState", "removeState"] }, text: function (e) { return e.i18n("buttons.stateRestore", "State %d", e.stateRestore.states()[0].length + 1) } }, c.ext.buttons.updateState = { action: function (e, t, s, o) { y("div.dt-button-background").click(), o.parent._stateRestore.save() }, text: function (e) { return e.i18n("buttons.updateState", "Update") } }, c.ext.buttons.savedStates = { buttons: [], extend: "collection", init: function (e, t, s) { e.on("stateRestore-change", function () { e.button(t).text(e.i18n("buttons.savedStates", "Saved States", e.stateRestore.states().length)) }), void 0 === e.settings()[0]._stateRestore && o(e, s) }, name: "SaveStateRestore", text: function (e) { return e.i18n("buttons.savedStates", "Saved States", 0) } }, c.ext.buttons.savedStatesCreate = { buttons: [], extend: "collection", init: function (e, t, s) { e.on("stateRestore-change", function () { e.button(t).text(e.i18n("buttons.savedStates", "Saved States", e.stateRestore.states().length)) }), void 0 === e.settings()[0]._stateRestore && (void 0 === s.config && (s.config = {}), s.config._createInSaved = !0, o(e, s)) }, name: "SaveStateRestore", text: function (e) { return e.i18n("buttons.savedStates", "Saved States", 0) } }, c.ext.buttons.createState = { action: function (e, t, s, o) { e.stopPropagation(); var i = t.settings()[0]._stateRestore.c, e = t.settings()[0].oLanguage; if (i.create && i.save) { var a = t.stateRestore.states().toArray(), e = void 0 !== e.buttons && void 0 !== e.buttons.stateRestore ? e.buttons.stateRestore : "State "; if (e.indexOf("%d") === e.length - 3) n = new RegExp(e.replace(/%d/g, "")); else for (var e = e.split("%d"), n = [], r = 0, c = e; r < c.length; r++) { var l = c[r]; n.push(new RegExp(l)) } for (var d = function (e) { if (Array.isArray(n)) { i = e; for (var t = 0, s = n; t < s.length; t++)var o = s[t], i = i.replace(o, "") } else i = e.replace(n, ""); return isNaN(+i) || i.length === e ? 0 : +i }, e = a.map(function (e) { return d(e.s.identifier) }).sort(function (e, t) { return +e < +t ? 1 : +t < +e ? -1 : 0 })[0], h = (t.stateRestore.state.add(t.i18n("buttons.stateRestore", "State %d", void 0 !== e ? e + 1 : 1), o.config), t.stateRestore.states().sort(function (e, t) { e = +d(e.s.identifier), t = +d(t.s.identifier); return t < e ? 1 : e < t ? -1 : 0 })), a = t.button("SaveStateRestore:name"), u = void 0 !== a[0] && void 0 !== a[0].inst.c.buttons[0].buttons ? a[0].inst.c.buttons[0].buttons : [], m = 0; m < u.length; m++)"stateRestore" === u[m].extend && (u.splice(m, 1), m--); i._createInSaved && u.push("createState"); for (var v = 0, g = h; v < g.length; v++) { var p = g[v], f = i.splitSecondaries.slice(); f.includes("updateState") && !i.save && f.splice(f.indexOf("updateState"), 1), !f.includes("renameState") || i.save && i.rename || f.splice(f.indexOf("renameState"), 1), f.includes("removeState") && !i.remove && f.splice(f.indexOf("removeState"), 1), u.push({ _stateRestore: p, attr: { title: p.s.identifier }, config: { split: f }, extend: "stateRestore", text: k.entityEncode(p.s.identifier), popoverTitle: k.entityEncode(p.s.identifier) }) } t.button("SaveStateRestore:name").collectionRebuild(u), s.blur(); for (var b = 0, S = t.buttons(); b < S.length; b++) { var R = S[b]; y(R.node).hasClass("dtsr-removeAllStates") && (0 === h.length ? t.button(R.node).disable() : t.button(R.node).enable()) } } }, init: function (e, t, s) { void 0 === e.settings()[0]._stateRestore && 1 < e.button("SaveStateRestore:name").length && o(e, s) }, text: function (e) { return e.i18n("buttons.createState", "Create State") } }, c.ext.buttons.removeState = { action: function (e, t, s, o) { o.parent._stateRestore.remove(), s.blur() }, text: function (e) { return e.i18n("buttons.removeState", "Remove") } }, c.ext.buttons.removeAllStates = { action: function (e, t, s) { t.stateRestore.states().remove(!0), s.blur() }, className: "dt-button dtsr-removeAllStates", init: function (e, t) { e.settings()[0]._stateRestore && 0 !== e.stateRestore.states().length || y(t).addClass("disabled") }, text: function (e) { return e.i18n("buttons.removeAllStates", "Remove All States") } }, c.ext.buttons.renameState = { action: function (e, t, s, o) { for (var i = [], a = 0, n = t.settings()[0]._stateRestore.s.states; a < n.length; a++) { var r = n[a]; i.push(r.s.identifier) } o.parent._stateRestore.rename(void 0, i), s.blur() }, text: function (e) { return e.i18n("buttons.renameState", "Rename") } }, y(g).on("preInit.dt.dtsr", function (e, t) { "dt" !== e.namespace || !t.oInit.stateRestore && !c.defaults.stateRestore || t._stateRestore || (e = t, void 0 === (t = null) && (t = null), e = new c.Api(e), t = t || e.init().stateRestore || c.defaults.stateRestore, t = new s(e, t), l(e, t)) }), c });
/*! Bootstrap 4 styling wrapper for FixedHeader
 * © SpryMedia Ltd - datatables.net/license
 */
!function (t) { var d, a; "function" == typeof define && define.amd ? define(["jquery", "datatables.net-bs4", "datatables.net-fixedheader"], function (e) { return t(e, window, document) }) : "object" == typeof exports ? (d = require("jquery"), a = function (e, n) { n.fn.dataTable || require("datatables.net-bs4")(e, n), n.fn.dataTable.FixedHeader || require("datatables.net-fixedheader")(e, n) }, "undefined" == typeof window ? module.exports = function (e, n) { return e = e || window, n = n || d(e), a(e, n), t(n, 0, e.document) } : (a(window, d), module.exports = t(d, window, window.document))) : t(jQuery, window, document) }(function (e, n, t) { "use strict"; return e.fn.dataTable });
/*! Bootstrap 4 styling wrapper for Scroller
 * © SpryMedia Ltd - datatables.net/license
 */
!function (t) { var o, d; "function" == typeof define && define.amd ? define(["jquery", "datatables.net-bs4", "datatables.net-scroller"], function (e) { return t(e, window, document) }) : "object" == typeof exports ? (o = require("jquery"), d = function (e, n) { n.fn.dataTable || require("datatables.net-bs4")(e, n), n.fn.dataTable.Scroller || require("datatables.net-scroller")(e, n) }, "undefined" == typeof window ? module.exports = function (e, n) { return e = e || window, n = n || o(e), d(e, n), t(n, 0, e.document) } : (d(window, o), module.exports = t(o, window, window.document))) : t(jQuery, window, document) }(function (e, n, t) { "use strict"; return e.fn.dataTable });
/*! Bootstrap integration for DataTables' StateRestore
 * © SpryMedia Ltd - datatables.net/license
 */
!function (n) { var o, r; "function" == typeof define && define.amd ? define(["jquery", "datatables.net-bs4", "datatables.net-staterestore"], function (t) { return n(t, window, document) }) : "object" == typeof exports ? (o = require("jquery"), r = function (t, e) { e.fn.dataTable || require("datatables.net-bs4")(t, e), e.fn.dataTable.StateRestore || require("datatables.net-staterestore")(t, e) }, "undefined" == typeof window ? module.exports = function (t, e) { return t = t || window, e = e || o(t), r(t, e), n(e, 0, t.document) } : (r(window, o), module.exports = n(o, window, window.document))) : n(jQuery, window, document) }(function (t, e, n) { "use strict"; var o = t.fn.dataTable; return t.extend(!0, o.StateRestoreCollection.classes, { checkBox: "dtsr-check-box", creationButton: "dtsr-creation-button btn btn-secondary", creationForm: "dtsr-creation-form modal-body", creationText: "dtsr-creation-text modal-header", creationTitle: "dtsr-creation-title modal-title", nameInput: "dtsr-name-input form-control" }), t.extend(!0, o.StateRestore.classes, { confirmationButton: "dtsr-confirmation-button btn btn-secondary", input: "dtsr-input form-control" }), o });
/*! Bootstrap 4 integration for DataTables' Responsive
 * © SpryMedia Ltd - datatables.net/license
 */
!function (n) { var a, t; "function" == typeof define && define.amd ? define(["jquery", "datatables.net-bs4", "datatables.net-responsive"], function (e) { return n(e, window, document) }) : "object" == typeof exports ? (a = require("jquery"), t = function (e, d) { d.fn.dataTable || require("datatables.net-bs4")(e, d), d.fn.dataTable.Responsive || require("datatables.net-responsive")(e, d) }, "undefined" == typeof window ? module.exports = function (e, d) { return e = e || window, d = d || a(e), t(e, d), n(d, 0, e.document) } : (t(window, a), module.exports = n(a, window, window.document))) : n(jQuery, window, document) }(function (s, e, l) { "use strict"; var d = s.fn.dataTable, n = d.Responsive.display, u = n.modal, m = s('<div class="modal fade dtr-bs-modal" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body"/></div></div></div>'); return n.modal = function (r) { return function (e, d, n, a) { if (s.fn.modal) { var t, o, i = n(); if (!1 === i) return !1; if (d) { if (!s.contains(l, m[0]) || e.index() !== m.data("dtr-row-idx")) return null; m.find("div.modal-body").empty().append(i) } else r && r.header && (o = (t = m.find("div.modal-header")).find("button").detach(), t.empty().append('<h4 class="modal-title">' + r.header(e) + "</h4>").append(o)), m.find("div.modal-body").empty().append(i), m.data("dtr-row-idx", e.index()).one("hidden.bs.modal", a).appendTo("body").modal(); return !0 } return u(e, d, n, a) } }, d });
/*!
 * HTML5 export buttons for Buttons and DataTables.
 * © SpryMedia Ltd - datatables.net/license
 *
 * FileSaver.js (1.3.3) - MIT license
 * Copyright © 2016 Eli Grey - http://eligrey.com
 */
!function (o) { var l, n; "function" == typeof define && define.amd ? define(["jquery", "datatables.net", "datatables.net-buttons"], function (t) { return o(t, window, document) }) : "object" == typeof exports ? (l = require("jquery"), n = function (t, e) { e.fn.dataTable || require("datatables.net")(t, e), e.fn.dataTable.Buttons || require("datatables.net-buttons")(t, e) }, "undefined" == typeof window ? module.exports = function (t, e) { return t = t || window, e = e || l(t), n(t, e), o(e, t, t.document) } : (n(window, l), module.exports = o(l, window, window.document))) : o(jQuery, window, document) }(function (S, C, u) { "use strict"; var e, o, t = S.fn.dataTable; function T() { return e || C.JSZip } function m() { return o || C.pdfMake } t.Buttons.pdfMake = function (t) { if (!t) return m(); o = t }, t.Buttons.jszip = function (t) { if (!t) return T(); e = t }; function k(t) { var e = "Sheet1"; return e = t.sheetName ? t.sheetName.replace(/[\[\]\*\/\\\?\:]/g, "") : e } function c(t, e) { function o(t) { for (var e = "", o = 0, l = t.length; o < l; o++)0 < o && (e += a), e += r ? r + ("" + t[o]).replace(d, p + r) + r : t[o]; return e } var l = y(e), n = t.buttons.exportData(e.exportOptions), r = e.fieldBoundary, a = e.fieldSeparator, d = new RegExp(r, "g"), p = void 0 !== e.escapeChar ? e.escapeChar : "\\", t = "", i = "", f = []; e.header && (t = n.headerStructure.map(function (t) { return o(t.map(function (t) { return t ? t.title : "" })) }).join(l) + l), e.footer && n.footer && (i = n.footerStructure.map(function (t) { return o(t.map(function (t) { return t ? t.title : "" })) }).join(l) + l); for (var m = 0, s = n.body.length; m < s; m++)f.push(o(n.body[m])); return { str: t + f.join(l) + l + i, rows: f.length } } function s() { var t; return -1 !== navigator.userAgent.indexOf("Safari") && -1 === navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Opera") && !!((t = navigator.userAgent.match(/AppleWebKit\/(\d+\.\d+)/)) && 1 < t.length && +t[1] < 603.1) } var N = function (d) { var p, i, f, m, s, u, e, c, y, l, t; if (!(void 0 === d || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) return t = d.document, p = function () { return d.URL || d.webkitURL || d }, i = t.createElementNS("http://www.w3.org/1999/xhtml", "a"), f = "download" in i, m = /constructor/i.test(d.HTMLElement) || d.safari, s = /CriOS\/[\d]+/.test(navigator.userAgent), u = function (t) { (d.setImmediate || d.setTimeout)(function () { throw t }, 0) }, e = 4e4, c = function (t) { setTimeout(function () { "string" == typeof t ? p().revokeObjectURL(t) : t.remove() }, e) }, y = function (t) { return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t }, t = (l = function (t, o, e) { e || (t = y(t)); var l, n, r = this, e = "application/octet-stream" === t.type, a = function () { for (var t = r, e = "writestart progress write writeend".split(" "), o = void 0, l = (e = [].concat(e)).length; l--;) { var n = t["on" + e[l]]; if ("function" == typeof n) try { n.call(t, o || t) } catch (t) { u(t) } } }; r.readyState = r.INIT, f ? (l = p().createObjectURL(t), setTimeout(function () { var t, e; i.href = l, i.download = o, t = i, e = new MouseEvent("click"), t.dispatchEvent(e), a(), c(l), r.readyState = r.DONE })) : (s || e && m) && d.FileReader ? ((n = new FileReader).onloadend = function () { var t = s ? n.result : n.result.replace(/^data:[^;]*;/, "data:attachment/file;"); d.open(t, "_blank") || (d.location.href = t), r.readyState = r.DONE, a() }, n.readAsDataURL(t), r.readyState = r.INIT) : (l = l || p().createObjectURL(t), !e && d.open(l, "_blank") || (d.location.href = l), r.readyState = r.DONE, a(), c(l)) }).prototype, "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function (t, e, o) { return e = e || t.name || "download", o || (t = y(t)), navigator.msSaveOrOpenBlob(t, e) } : (t.abort = function () { }, t.readyState = t.INIT = 0, t.WRITING = 1, t.DONE = 2, t.error = t.onwritestart = t.onprogress = t.onwrite = t.onabort = t.onerror = t.onwriteend = null, function (t, e, o) { return new l(t, e || t.name || "download", o) }) }("undefined" != typeof self && self || void 0 !== C && C || this.content), y = (t.fileSave = N, function (t) { return t.newline || (navigator.userAgent.match(/Windows/) ? "\r\n" : "\n") }); function z(t) { for (var e = "A".charCodeAt(0), o = "Z".charCodeAt(0) - e + 1, l = ""; 0 <= t;)l = String.fromCharCode(t % o + e) + l, t = Math.floor(t / o) - 1; return l } try { var O, D = new XMLSerializer } catch (t) { } function E(t, e, o) { var l = t.createElement(e); return o && (o.attr && S(l).attr(o.attr), o.children && S.each(o.children, function (t, e) { l.appendChild(e) }), null !== o.text) && void 0 !== o.text && l.appendChild(t.createTextNode(o.text)), l } function A(t, e, o, l, n) { var r = S("mergeCells", t); r[0].appendChild(E(t, "mergeCell", { attr: { ref: z(o) + e + ":" + z(o + n - 1) + (e + l - 1) } })), r.attr("count", parseFloat(r.attr("count")) + 1) } var R = { "_rels/.rels": '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>', "xl/_rels/workbook.xml.rels": '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/></Relationships>', "[Content_Types].xml": '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="xml" ContentType="application/xml" /><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="jpeg" ContentType="image/jpeg" /><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" /><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" /></Types>', "xl/workbook.xml": '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="24816"/><workbookPr showInkAnnotation="0" autoCompressPictures="0"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="25600" windowHeight="19020" tabRatio="500"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><definedNames/></workbook>', "xl/worksheets/sheet1.xml": '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><sheetData/><mergeCells count="0"/></worksheet>', "xl/styles.xml": '<?xml version="1.0" encoding="UTF-8"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><numFmts count="6"><numFmt numFmtId="164" formatCode="[$$-409]#,##0.00;-[$$-409]#,##0.00"/><numFmt numFmtId="165" formatCode="&quot;£&quot;#,##0.00"/><numFmt numFmtId="166" formatCode="[$€-2] #,##0.00"/><numFmt numFmtId="167" formatCode="0.0%"/><numFmt numFmtId="168" formatCode="#,##0;(#,##0)"/><numFmt numFmtId="169" formatCode="#,##0.00;(#,##0.00)"/></numFmts><fonts count="5" x14ac:knownFonts="1"><font><sz val="11" /><name val="Calibri" /></font><font><sz val="11" /><name val="Calibri" /><color rgb="FFFFFFFF" /></font><font><sz val="11" /><name val="Calibri" /><b /></font><font><sz val="11" /><name val="Calibri" /><i /></font><font><sz val="11" /><name val="Calibri" /><u /></font></fonts><fills count="6"><fill><patternFill patternType="none" /></fill><fill><patternFill patternType="none" /></fill><fill><patternFill patternType="solid"><fgColor rgb="FFD9D9D9" /><bgColor indexed="64" /></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="FFD99795" /><bgColor indexed="64" /></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="ffc6efce" /><bgColor indexed="64" /></patternFill></fill><fill><patternFill patternType="solid"><fgColor rgb="ffc6cfef" /><bgColor indexed="64" /></patternFill></fill></fills><borders count="2"><border><left /><right /><top /><bottom /><diagonal /></border><border diagonalUp="false" diagonalDown="false"><left style="thin"><color auto="1" /></left><right style="thin"><color auto="1" /></right><top style="thin"><color auto="1" /></top><bottom style="thin"><color auto="1" /></bottom><diagonal /></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" /></cellStyleXfs><cellXfs count="68"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="3" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="1" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="2" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="3" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="4" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"><alignment horizontal="left"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"><alignment horizontal="center"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"><alignment horizontal="right"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"><alignment horizontal="fill"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"><alignment textRotation="90"/></xf><xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1"><alignment wrapText="1"/></xf><xf numFmtId="9"   fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="164" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="165" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="166" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="167" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="168" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="169" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="3" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="4" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="1" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="2" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/><xf numFmtId="14" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyNumberFormat="1"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0" /></cellStyles><dxfs count="0" /><tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4" /></styleSheet>' }, _ = [{ match: /^\-?\d+\.\d%$/, style: 60, fmt: function (t) { return t / 100 } }, { match: /^\-?\d+\.?\d*%$/, style: 56, fmt: function (t) { return t / 100 } }, { match: /^\-?\$[\d,]+.?\d*$/, style: 57 }, { match: /^\-?£[\d,]+.?\d*$/, style: 58 }, { match: /^\-?€[\d,]+.?\d*$/, style: 59 }, { match: /^\-?\d+$/, style: 65 }, { match: /^\-?\d+\.\d{2}$/, style: 66 }, { match: /^\([\d,]+\)$/, style: 61, fmt: function (t) { return -1 * t.replace(/[\(\)]/g, "") } }, { match: /^\([\d,]+\.\d{2}\)$/, style: 62, fmt: function (t) { return -1 * t.replace(/[\(\)]/g, "") } }, { match: /^\-?[\d,]+$/, style: 63 }, { match: /^\-?[\d,]+\.\d{2}$/, style: 64 }, { match: /^(19\d\d|[2-9]\d\d\d)\-(0\d|1[012])\-[0123][\d]$/, style: 67, fmt: function (t) { return Math.round(25569 + Date.parse(t) / 864e5) } }]; return t.ext.buttons.copyHtml5 = { className: "buttons-copy buttons-html5", text: function (t) { return t.i18n("buttons.copy", "Copy") }, action: function (t, e, o, l, n) { var r = c(e, l), a = e.buttons.exportInfo(l), d = y(l), p = r.str, i = S("<div/>").css({ height: 1, width: 1, overflow: "hidden", position: "fixed", top: 0, left: 0 }), d = (a.title && (p = a.title + d + d + p), a.messageTop && (p = a.messageTop + d + d + p), a.messageBottom && (p = p + d + d + a.messageBottom), l.customize && (p = l.customize(p, l, e)), S("<textarea readonly/>").val(p).appendTo(i)); if (u.queryCommandSupported("copy")) { i.appendTo(e.table().container()), d[0].focus(), d[0].select(); try { var f = u.execCommand("copy"); if (i.remove(), f) return e.buttons.info(e.i18n("buttons.copyTitle", "Copy to clipboard"), e.i18n("buttons.copySuccess", { 1: "Copied one row to clipboard", _: "Copied %d rows to clipboard" }, r.rows), 2e3), void n() } catch (t) { } } function m() { s.off("click.buttons-copy"), S(u).off(".buttons-copy"), e.buttons.info(!1) } var a = S("<span>" + e.i18n("buttons.copyKeys", "Press <i>ctrl</i> or <i>⌘</i> + <i>C</i> to copy the table data<br>to your system clipboard.<br><br>To cancel, click this message or press escape.") + "</span>").append(i), s = (e.buttons.info(e.i18n("buttons.copyTitle", "Copy to clipboard"), a, 0), d[0].focus(), d[0].select(), S(a).closest(".dt-button-info")); s.on("click.buttons-copy", m), S(u).on("keydown.buttons-copy", function (t) { 27 === t.keyCode && (m(), n()) }).on("copy.buttons-copy cut.buttons-copy", function () { m(), n() }) }, async: 100, exportOptions: {}, fieldSeparator: "\t", fieldBoundary: "", header: !0, footer: !0, title: "*", messageTop: "*", messageBottom: "*" }, t.ext.buttons.csvHtml5 = { bom: !1, className: "buttons-csv buttons-html5", available: function () { return void 0 !== C.FileReader && C.Blob }, text: function (t) { return t.i18n("buttons.csv", "CSV") }, action: function (t, e, o, l, n) { var r = c(e, l).str, a = e.buttons.exportInfo(l), d = l.charset; l.customize && (r = l.customize(r, l, e)), d = !1 !== d ? (d = d || u.characterSet || u.charset) && ";charset=" + d : "", l.bom && (r = String.fromCharCode(65279) + r), N(new Blob([r], { type: "text/csv" + d }), a.filename, !0), n() }, async: 100, filename: "*", extension: ".csv", exportOptions: {}, fieldSeparator: ",", fieldBoundary: '"', escapeChar: '"', charset: null, header: !0, footer: !0 }, t.ext.buttons.excelHtml5 = { className: "buttons-excel buttons-html5", available: function () { return void 0 !== C.FileReader && void 0 !== T() && !s() && D }, text: function (t) { return t.i18n("buttons.excel", "Excel") }, action: function (t, e, o, f, l) { function n(t) { return t = R[t], S.parseXML(t) } function r(t) { s = E(c, "row", { attr: { r: m = u + 1 } }); for (var e = 0, o = t.length; e < o; e++) { var l = z(e) + "" + m, n = null; if (null === t[e] || void 0 === t[e] || "" === t[e]) { if (!0 !== f.createEmptyCells) continue; t[e] = "" } var r = t[e]; t[e] = "function" == typeof t[e].trim ? t[e].trim() : t[e]; for (var a = 0, d = _.length; a < d; a++) { var p = _[a]; if (t[e].match && !t[e].match(/^0\d+/) && t[e].match(p.match)) { var i = t[e].replace(/[^\d\.\-]/g, ""); p.fmt && (i = p.fmt(i)), n = E(c, "c", { attr: { r: l, s: p.style }, children: [E(c, "v", { text: i })] }); break } } n = n || ("number" == typeof t[e] || t[e].match && t[e].match(/^-?\d+(\.\d+)?([eE]\-?\d+)?$/) && !t[e].match(/^0\d+/) ? E(c, "c", { attr: { t: "n", r: l }, children: [E(c, "v", { text: t[e] })] }) : (r = r.replace ? r.replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, "") : r, E(c, "c", { attr: { t: "inlineStr", r: l }, children: { row: E(c, "is", { children: { row: E(c, "t", { text: r, attr: { "xml:space": "preserve" } }) } }) } }))), s.appendChild(n) } y.appendChild(s), u++ } function a(t) { t.forEach(function (t) { r(t.map(function (t) { return t ? t.title : "" })), S("row:last c", c).attr("s", "2"), t.forEach(function (t, e) { t && (1 < t.colSpan || 1 < t.rowSpan) && A(c, u, e, t.rowSpan, t.colSpan) }) }) } var d, m, s, u = 0, c = n("xl/worksheets/sheet1.xml"), y = c.getElementsByTagName("sheetData")[0], p = { _rels: { ".rels": n("_rels/.rels") }, xl: { _rels: { "workbook.xml.rels": n("xl/_rels/workbook.xml.rels") }, "workbook.xml": n("xl/workbook.xml"), "styles.xml": n("xl/styles.xml"), worksheets: { "sheet1.xml": c } }, "[Content_Types].xml": n("[Content_Types].xml") }, i = e.buttons.exportData(f.exportOptions), I = (f.customizeData && f.customizeData(i), e.buttons.exportInfo(f)); I.title && (r([I.title]), A(c, u, 0, 1, i.header.length), S("row:last c", c).attr("s", "51")), I.messageTop && (r([I.messageTop]), A(c, u, 0, 1, i.header.length)), f.header && a(i.headerStructure); for (var F = u, x = 0, h = i.body.length; x < h; x++)r(i.body[x]); d = u, f.footer && i.footer && a(i.footerStructure), I.messageBottom && (r([I.messageBottom]), A(c, u, 0, 1, i.header.length)); var b = E(c, "cols"); S("worksheet", c).prepend(b); for (var g = 0, v = i.header.length; g < v; g++)b.appendChild(E(c, "col", { attr: { min: g + 1, max: g + 1, width: function (t, e) { var o = t.header[e].length; t.footer && t.footer[e] && t.footer[e].length > o && (o = t.footer[e].length); for (var l = 0, n = t.body.length; l < n; l++) { var r, a = t.body[l][e]; if (40 < (o = o < (r = (-1 !== (a = null != a ? a.toString() : "").indexOf("\n") ? ((r = a.split("\n")).sort(function (t, e) { return e.length - t.length }), r[0]) : a).length) ? r : o)) return 54 } return 6 < (o *= 1.35) ? o : 6 }(i, g), customWidth: 1 } })); var w = p.xl["workbook.xml"]; S("sheets sheet", w).attr("name", k(f)), f.autoFilter && (S("mergeCells", c).before(E(c, "autoFilter", { attr: { ref: "A" + F + ":" + z(i.header.length - 1) + d } })), S("definedNames", w).append(E(w, "definedName", { attr: { name: "_xlnm._FilterDatabase", localSheetId: "0", hidden: 1 }, text: "'" + k(f).replace(/'/g, "''") + "'!$A$" + F + ":" + z(i.header.length - 1) + d }))), f.customize && f.customize(p, f, e), 0 === S("mergeCells", c).children().length && S("mergeCells", c).remove(); var w = new (T()), F = { compression: "DEFLATE", type: "blob", mimeType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }, B = (!function f(m, t) { void 0 === O && (O = -1 === D.serializeToString((new C.DOMParser).parseFromString(R["xl/worksheets/sheet1.xml"], "text/xml")).indexOf("xmlns:r")), S.each(t, function (t, e) { if (S.isPlainObject(e)) f(m.folder(t), e); else { if (O) { for (var o, l = e.childNodes[0], n = [], r = l.attributes.length - 1; 0 <= r; r--) { var a = l.attributes[r].nodeName, d = l.attributes[r].nodeValue; -1 !== a.indexOf(":") && (n.push({ name: a, value: d }), l.removeAttribute(a)) } for (r = 0, o = n.length; r < o; r++) { var p = e.createAttribute(n[r].name.replace(":", "_dt_b_namespace_token_")); p.value = n[r].value, l.setAttributeNode(p) } } var i = D.serializeToString(e), i = (i = O ? (i = (i = -1 === i.indexOf("<?xml") ? '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + i : i).replace(/_dt_b_namespace_token_/g, ":")).replace(/xmlns:NS[\d]+="" NS[\d]+:/g, "") : i).replace(/<([^<>]*?) xmlns=""([^<>]*?)>/g, "<$1 $2>"); m.file(t, i) } }) }(w, p), I.filename); 175 < B && (B = B.substr(0, 175)), f.customizeZip && f.customizeZip(w, i, B), w.generateAsync ? w.generateAsync(F).then(function (t) { N(t, B), l() }) : (N(w.generate(F), B), l()) }, async: 100, filename: "*", extension: ".xlsx", exportOptions: {}, header: !0, footer: !0, title: "*", messageTop: "*", messageBottom: "*", createEmptyCells: !1, autoFilter: !1, sheetName: "" }, t.ext.buttons.pdfHtml5 = { className: "buttons-pdf buttons-html5", available: function () { return void 0 !== C.FileReader && m() }, text: function (t) { return t.i18n("buttons.pdf", "PDF") }, action: function (t, e, o, l, n) { var r = e.buttons.exportData(l.exportOptions), a = e.buttons.exportInfo(l), d = []; l.header && r.headerStructure.forEach(function (t) { d.push(t.map(function (t) { return t ? { text: t.title, colSpan: t.colspan, rowSpan: t.rowspan, style: "tableHeader" } : {} })) }); for (var p = 0, i = r.body.length; p < i; p++)d.push(r.body[p].map(function (t) { return { text: null == t ? "" : "string" == typeof t ? t : t.toString() } })); l.footer && r.footerStructure.forEach(function (t) { d.push(t.map(function (t) { return t ? { text: t.title, colSpan: t.colspan, rowSpan: t.rowspan, style: "tableHeader" } : {} })) }); var f = { pageSize: l.pageSize, pageOrientation: l.orientation, content: [{ style: "table", table: { headerRows: r.headerStructure.length, footerRows: r.footerStructure.length, body: d }, layout: { hLineWidth: function (t, e) { return 0 === t || t === e.table.body.length ? 0 : .5 }, vLineWidth: function () { return 0 }, hLineColor: function (t, e) { return t === e.table.headerRows || t === e.table.body.length - e.table.footerRows ? "#333" : "#ddd" }, fillColor: function (t) { return t < r.headerStructure.length ? "#fff" : t % 2 == 0 ? "#f3f3f3" : null }, paddingTop: function () { return 5 }, paddingBottom: function () { return 5 } } }], styles: { tableHeader: { bold: !0, fontSize: 11, alignment: "center" }, tableFooter: { bold: !0, fontSize: 11 }, table: { margin: [0, 5, 0, 5] }, title: { alignment: "center", fontSize: 13 }, message: {} }, defaultStyle: { fontSize: 10 } }, e = (a.messageTop && f.content.unshift({ text: a.messageTop, style: "message", margin: [0, 0, 0, 12] }), a.messageBottom && f.content.push({ text: a.messageBottom, style: "message", margin: [0, 0, 0, 12] }), a.title && f.content.unshift({ text: a.title, style: "title", margin: [0, 0, 0, 12] }), l.customize && l.customize(f, l, e), m().createPdf(f)); "open" !== l.download || s() ? e.download(a.filename) : e.open(), n() }, async: 100, title: "*", filename: "*", extension: ".pdf", exportOptions: {}, orientation: "portrait", pageSize: "en-US" === navigator.language || "en-CA" === navigator.language ? "LETTER" : "A4", header: !0, footer: !0, messageTop: "*", messageBottom: "*", customize: null, download: "download" }, t });
/*!
 * Print button for Buttons and DataTables.
 * © SpryMedia Ltd - datatables.net/license
 */
!function (n) { var o, r; "function" == typeof define && define.amd ? define(["jquery", "datatables.net", "datatables.net-buttons"], function (t) { return n(t, window, document) }) : "object" == typeof exports ? (o = require("jquery"), r = function (t, e) { e.fn.dataTable || require("datatables.net")(t, e), e.fn.dataTable.Buttons || require("datatables.net-buttons")(t, e) }, "undefined" == typeof window ? module.exports = function (t, e) { return t = t || window, e = e || o(t), r(t, e), n(e, t, t.document) } : (r(window, o), module.exports = n(o, window, window.document))) : n(jQuery, window, document) }(function (f, m, t) { "use strict"; function b(t) { return n.href = t, -1 === (t = n.host).indexOf("/") && 0 !== n.pathname.indexOf("/") && (t += "/"), n.protocol + "//" + t + n.pathname + n.search } var e = f.fn.dataTable, n = t.createElement("a"); return e.ext.buttons.print = { className: "buttons-print", text: function (t) { return t.i18n("buttons.print", "Print") }, action: function (t, e, n, o, r) { var i = e.buttons.exportData(f.extend({ decodeEntities: !1 }, o.exportOptions)), a = e.buttons.exportInfo(o), u = e.columns(o.exportOptions.columns).nodes().map(function (t) { return t.className }).toArray(), s = '<table class="' + e.table().node().className + '">'; o.header && (s += "<thead>" + i.headerStructure.map(function (t) { return "<tr>" + t.map(function (t) { return t ? '<th colspan="' + t.colspan + '" rowspan="' + t.rowspan + '">' + t.title + "</th>" : "" }).join("") + "</tr>" }).join("") + "</thead>"), s += "<tbody>"; for (var c = 0, d = i.body.length; c < d; c++)s += function (t, e) { for (var n = "<tr>", o = 0, r = t.length; o < r; o++) { var i = null === t[o] || void 0 === t[o] ? "" : t[o]; n += "<" + e + " " + (u[o] ? 'class="' + u[o] + '"' : "") + ">" + i + "</" + e + ">" } return n + "</tr>" }(i.body[c], "td"); s += "</tbody>", o.footer && i.footer && (s += "<tfoot>" + i.footerStructure.map(function (t) { return "<tr>" + t.map(function (t) { return t ? '<th colspan="' + t.colspan + '" rowspan="' + t.rowspan + '">' + t.title + "</th>" : "" }).join("") + "</tr>" }).join("") + "</tfoot>"), s += "</table>"; var l = m.open("", ""); if (l) { l.document.close(); var p = "<title>" + a.title + "</title>"; f("style, link").each(function () { p += function (t) { t = f(t).clone()[0]; return "link" === t.nodeName.toLowerCase() && (t.href = b(t.href)), t.outerHTML }(this) }); try { l.document.head.innerHTML = p } catch (t) { f(l.document.head).html(p) } o.customScripts && o.customScripts.forEach(function (t) { var e = l.document.createElement("script"); e.src = t, l.document.getElementsByTagName("head")[0].appendChild(e) }), l.document.body.innerHTML = "<h1>" + a.title + "</h1><div>" + (a.messageTop || "") + "</div>" + s + "<div>" + (a.messageBottom || "") + "</div>", f(l.document.body).addClass("dt-print-view"), f("img", l.document.body).each(function (t, e) { e.setAttribute("src", b(e.getAttribute("src"))) }), o.customize && o.customize(l, o, e); l.setTimeout(function () { o.autoPrint && (l.print(), l.close()) }, 1e3), r() } else e.buttons.info(e.i18n("buttons.printErrorTitle", "Unable to open print view"), e.i18n("buttons.printErrorMsg", "Please allow popups in your browser for this site to be able to view the print view."), 5e3) }, async: 100, title: "*", messageTop: "*", messageBottom: "*", exportOptions: {}, header: !0, footer: !0, autoPrint: !0, customize: null }, e });
/*! Bootstrap 4 styling wrapper for ColReorder
 * © SpryMedia Ltd - datatables.net/license
 */
!function (t) { var o, d; "function" == typeof define && define.amd ? define(["jquery", "datatables.net-bs4", "datatables.net-colreorder"], function (e) { return t(e, window, document) }) : "object" == typeof exports ? (o = require("jquery"), d = function (e, n) { n.fn.dataTable || require("datatables.net-bs4")(e, n), n.fn.dataTable.ColReorder || require("datatables.net-colreorder")(e, n) }, "undefined" == typeof window ? module.exports = function (e, n) { return e = e || window, n = n || o(e), d(e, n), t(n, 0, e.document) } : (d(window, o), module.exports = t(o, window, window.document))) : t(jQuery, window, document) }(function (e, n, t) { "use strict"; return e.fn.dataTable });
/*! DataTables styling wrapper for Buttons
 * © SpryMedia Ltd - datatables.net/license
 */ !function (t) { if ("function" == typeof define && define.amd) define(["jquery", "datatables.net-dt", "datatables.net-buttons"], function (e) { return t(e, window, document) }); else if ("object" == typeof exports) { var e = require("jquery"), n = function (t, e) { e.fn.dataTable || require("datatables.net-dt")(t, e), e.fn.dataTable.Buttons || require("datatables.net-buttons")(t, e) }; "undefined" == typeof window ? module.exports = function (a, o) { return a || (a = window), o || (o = e(a)), n(a, o), t(o, a, a.document) } : (n(window, e), module.exports = t(e, window, window.document)) } else t(jQuery, window, document) }(function (t, e, n) { return !1, t.fn.dataTable });
/*! ColReorder 2.0.3
 * © SpryMedia Ltd - datatables.net/license
 */
!function (r) { var o, n; "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function (t) { return r(t, window, document) }) : "object" == typeof exports ? (o = require("jquery"), n = function (t, e) { e.fn.dataTable || require("datatables.net")(t, e) }, "undefined" == typeof window ? module.exports = function (t, e) { return t = t || window, e = e || o(t), n(t, e), r(e, 0, t.document) } : (n(window, o), module.exports = r(o, window, window.document))) : r(jQuery, window, document) }(function (u, t, h) {
    "use strict"; var n = u.fn.dataTable; function f(t, e, r, o) { var n = t.splice(e, r); n.unshift(0), n.unshift(o < e ? o : o - r + 1), t.splice.apply(t, n) } function l(t) { t.rows().invalidate("data"), t.column(0).visible(t.column(0).visible()), t.columns.adjust(); var e = t.colReorder.order(); t.trigger("columns-reordered", [{ order: e, mapping: g(e) }]) } function s(t) { return t.settings()[0].aoColumns.map(function (t) { return t._crOriginalIdx }) } function p(t, e, r, o) { for (var n = [], s = 0; s < t.length; s++) { var i = t[s]; f(i, r[0], r.length, o); for (var l = 0; l < i.length; l++) { var a, d = i[l].cell; n.includes(d) || (a = d.getAttribute("data-dt-column").split(",").map(function (t) { return e[t] }).join(","), d.setAttribute("data-dt-column", a), n.push(d)) } } } function i(t) { t.columns().iterator("column", function (t, e) { t = t.aoColumns; void 0 === t[e]._crOriginalIdx && (t[e]._crOriginalIdx = e) }) } function g(t) { for (var e = [], r = 0; r < t.length; r++)e[t[r]] = r; return e } function a(t, e, r) { var o, n = t.settings()[0], s = n.aoColumns, i = s.map(function (t, e) { return e }); if (!e.includes(r)) { f(i, e[0], e.length, r); var l = g(i); for (f(s, e[0], e.length, r), o = 0; o < n.aoData.length; o++) { var a = n.aoData[o]; if (a) { var d = a.anCells; if (d) for (f(d, e[0], e.length, r), u = 0; u < d.length; u++)a.nTr && d[u] && s[u].bVisible && a.nTr.appendChild(d[u]), d[u] && d[u]._DT_CellIndex && (d[u]._DT_CellIndex.column = u) } } for (o = 0; o < s.length; o++) { for (var c = s[o], u = 0; u < c.aDataSort.length; u++)c.aDataSort[u] = l[c.aDataSort[u]]; c.idx = l[c.idx], c.bVisible && n.colgroup.append(c.colEl) } p(n.aoHeader, l, e, r), p(n.aoFooter, l, e, r), f(n.aoPreSearchCols, e[0], e.length, r), m(l, n.aaSorting), Array.isArray(n.aaSortingFixed) ? m(l, n.aaSortingFixed) : (n.aaSortingFixed.pre || n.aaSortingFixed.post) && m(l, n.aaSortingFixed.pre), n.aLastSort.forEach(function (t) { t.src = l[t.src] }), t.trigger("column-reorder", [t.settings()[0], { from: e, to: r, mapping: l }]) } } function m(t, e) { if (e) for (var r = 0; r < e.length; r++) { var o = e[r]; "number" == typeof o ? e[r] = t[o] : u.isPlainObject(o) && void 0 !== o.idx ? o.idx = t[o.idx] : Array.isArray(o) && "number" == typeof o[0] && (o[0] = t[o[0]]) } } function d(t, e, r) { var o = !1; if (e.length !== t.columns().count()) t.error("ColReorder - column count mismatch"); else { for (var n = g(e = r ? c(t, e, "toCurrent") : e), s = 0; s < n.length; s++) { var i = n.indexOf(s); s !== i && (f(n, i, 1, s), a(t, [i], s), o = !0) } o && l(t) } } function c(t, e, r) { var o = t.colReorder.order(), n = t.settings()[0].aoColumns; return "toCurrent" === r || "fromOriginal" === r ? Array.isArray(e) ? e.map(function (t) { return o.indexOf(t) }) : o.indexOf(e) : Array.isArray(e) ? e.map(function (t) { return n[t]._crOriginalIdx }) : n[e]._crOriginalIdx } function v(t, e, r) { var o = t.columns().count(); return !(e[0] < r && r < e[e.length] || e[0] < 0 && e[e.length - 1] > o || r < 0 && o < r || !e.includes(r) && (!y(t.table().header.structure(), e, r) || !y(t.table().footer.structure(), e, r))) } function y(t, e, r) { for (var o = function (t) { for (var e = [], r = 0; r < t.length; r++) { e.push([]); for (var o = 0; o < t[r].length; o++) { var n = t[r][o]; if (n) for (var s = 0; s < n.rowspan; s++) { e[r + s] || (e[r + s] = []); for (var i = 0; i < n.colspan; i++)e[r + s][o + i] = n.cell } } } return e }(t), n = 0; n < o.length; n++)f(o[n], e[0], e.length, r); for (n = 0; n < o.length; n++)for (var s = [], i = 0; i < o[n].length; i++) { var l = o[n][i]; if (s.includes(l)) { if (s[s.length - 1] !== l) return } else s.push(l) } return 1 } _.prototype.disable = function () { return this.c.enable = !1, this }, _.prototype.enable = function (t) { return !1 === (t = void 0 === t ? !0 : t) ? this.disable() : (this.c.enable = !0, this) }, _.prototype._addListener = function (t) { var e = this; u(t).on("selectstart.colReorder", function () { return !1 }).on("mousedown.colReorder touchstart.colReorder", function (t) { "mousedown" === t.type && 1 !== t.which || e.c.enable && e._mouseDown(t, this) }) }, _.prototype._createDragNode = function () { var t = this.s.mouse.target, e = t.parent(), r = e.parent(), o = r.parent(), n = t.clone(); this.dom.drag = u(o[0].cloneNode(!1)).addClass("dtcr-cloned").append(u(r[0].cloneNode(!1)).append(u(e[0].cloneNode(!1)).append(n[0]))).css({ position: "absolute", top: 0, left: 0, width: u(t).outerWidth(), height: u(t).outerHeight() }).appendTo("body") }, _.prototype._cursorPosition = function (t, e) { return (-1 !== t.type.indexOf("touch") ? t.originalEvent.touches[0] : t)[e] }, _.prototype._mouseDown = function (t, e) { for (var r = this, o = u(t.target).closest("th, td"), n = o.offset(), s = this.dt.columns(this.c.columns).indexes().toArray(), i = u(e).attr("data-dt-column").split(",").map(function (t) { return parseInt(t, 10) }), l = 0; l < i.length; l++)if (!s.includes(i[l])) return !1; this.s.mouse.start.x = this._cursorPosition(t, "pageX"), this.s.mouse.start.y = this._cursorPosition(t, "pageY"), this.s.mouse.offset.x = this._cursorPosition(t, "pageX") - n.left, this.s.mouse.offset.y = this._cursorPosition(t, "pageY") - n.top, this.s.mouse.target = o, this.s.mouse.targets = i; for (var a = 0; a < i.length; a++) { var d = this.dt.cells(null, i[a], { page: "current" }).nodes().to$(), c = "dtcr-moving"; 0 === a && (c += " dtcr-moving-first"), a === i.length - 1 && (c += " dtcr-moving-last"), d.addClass(c) } this._regions(i), this._scrollRegions(), u(h).on("mousemove.colReorder touchmove.colReorder", function (t) { r._mouseMove(t) }).on("mouseup.colReorder touchend.colReorder", function (t) { r._mouseUp(t) }) }, _.prototype._mouseMove = function (t) { if (null === this.dom.drag) { if (Math.pow(Math.pow(this._cursorPosition(t, "pageX") - this.s.mouse.start.x, 2) + Math.pow(this._cursorPosition(t, "pageY") - this.s.mouse.start.y, 2), .5) < 5) return; u(h.body).addClass("dtcr-dragging"), this._createDragNode() } this.dom.drag.css({ left: this._cursorPosition(t, "pageX") - this.s.mouse.offset.x, top: this._cursorPosition(t, "pageY") - this.s.mouse.offset.y }); var e = u(this.dt.table().node()).offset().left, r = this._cursorPosition(t, "pageX") - e, e = this.s.dropZones.find(function (t) { return t.left <= r && r <= t.left + t.width }); this.s.mouse.absLeft = this._cursorPosition(t, "pageX"), e && !e.self && this._move(e, r) }, _.prototype._mouseUp = function (t) { u(h).off(".colReorder"), u(h.body).removeClass("dtcr-dragging"), this.dom.drag && (this.dom.drag.remove(), this.dom.drag = null), this.s.scrollInterval && clearInterval(this.s.scrollInterval), this.dt.cells(".dtcr-moving").nodes().to$().removeClass("dtcr-moving dtcr-moving-first dtcr-moving-last") }, _.prototype._move = function (t, e) { var r, o, n = this, s = (this.dt.colReorder.move(this.s.mouse.targets, t.colIdx), this.s.mouse.targets = u(this.s.mouse.target).attr("data-dt-column").split(",").map(function (t) { return parseInt(t, 10) }), this._regions(this.s.mouse.targets), this.s.mouse.targets.filter(function (t) { return n.dt.column(t).visible() })), t = this.s.dropZones.find(function (t) { return t.colIdx === s[0] }), i = this.s.dropZones.indexOf(t); t.left > e && (o = t.left - e, r = this.s.dropZones[i - 1], t.left -= o, t.width += o, r) && (r.width -= o), (t = this.s.dropZones.find(function (t) { return t.colIdx === s[s.length - 1] })).left + t.width < e && (r = e - (t.left + t.width), o = this.s.dropZones[i + 1], t.width += r, o) && (o.left += r, o.width -= r) }, _.prototype._regions = function (n) { var s = this, i = [], l = 0, a = 0, d = this.dt.columns(this.c.columns).indexes().toArray(), c = this.dt.columns().widths(); this.dt.columns().every(function (t, e, r) { var o; this.visible() && (o = c[t], d.includes(t) && (v(s.dt, n, t) ? i.push({ colIdx: t, left: l - a, self: n[0] <= t && t <= n[n.length - 1], width: o + a }) : t < n[0] ? i.length && (i[i.length - 1].width += o) : t > n[n.length - 1] && (a += o)), l += o) }), this.s.dropZones = i }, _.prototype._isScrolling = function () { return this.dt.table().body().parentNode !== this.dt.table().header().parentNode }, _.prototype._scrollRegions = function () { var e, r, o, n; this._isScrolling() && (r = u((e = this).dt.table().container()).position().left, o = u(this.dt.table().container()).outerWidth(), n = this.dt.table().body().parentElement.parentElement, this.s.scrollInterval = setInterval(function () { var t = e.s.mouse.absLeft; t < r + 75 && n.scrollLeft ? n.scrollLeft -= 5 : r + o - 75 < t && n.scrollLeft < n.scrollWidth && (n.scrollLeft += 5) }, 25)) }, _.defaults = { columns: "", enable: !0, order: null }, _.version = "2.0.3";
/*! ColReorder 2.0.3
 * © SpryMedia Ltd - datatables.net/license
 */var b = _; function _(o, t) { this.dom = { drag: null }, this.c = { columns: null, enable: null, order: null }, this.s = { dropZones: [], mouse: { absLeft: -1, offset: { x: -1, y: -1 }, start: { x: -1, y: -1 }, target: null, targets: [] }, scrollInterval: null }; var e, r = this; o.settings()[0]._colReorder || ((o.settings()[0]._colReorder = this).dt = o, u.extend(this.c, _.defaults, t), i(o), o.on("stateSaveParams", function (t, e, r) { r.colReorder = s(o) }), o.on("destroy", function () { o.off(".colReorder"), o.colReorder.reset() }), t = o.state.loaded(), e = this.c.order, (e = t && t.colReorder ? t.colReorder : e) && o.ready(function () { d(o, e, !0) }), o.table().header.structure().forEach(function (t) { for (var e = 0; e < t.length; e++)t[e] && t[e].cell && r._addListener(t[e].cell) })) } return n.Api.register("colReorder.enable()", function (e) { return this.iterator("table", function (t) { t._colReorder && t._colReorder.enable(e) }) }), n.Api.register("colReorder.disable()", function () { return this.iterator("table", function (t) { t._colReorder && t._colReorder.disable() }) }), n.Api.register("colReorder.move()", function (t, e) { return i(this), v(this, t = Array.isArray(t) ? t : [t], e) ? this.tables().every(function () { a(this, t, e), l(this) }) : (this.error("ColReorder - invalid move"), this) }), n.Api.register("colReorder.order()", function (t, e) { return i(this), t ? this.tables().every(function () { d(this, t, e) }) : this.context.length ? s(this) : null }), n.Api.register("colReorder.reset()", function () { return i(this), this.tables().every(function () { var t = this.columns().every(function (t) { return t }).flatten().toArray(); d(this, t, !0) }) }), n.Api.register("colReorder.transpose()", function (t, e) { return i(this), c(this, t, e = e || "toCurrent") }), n.ColReorder = b, u(h).on("stateLoadInit.dt", function (t, e, r) { if ("dt" === t.namespace) { t = new n.Api(e); if (r.colReorder) if (t.ready()) d(t, r.colReorder, !0); else { m(g(r.colReorder), r.order); for (var o = 0; o < r.columns.length; o++)r.columns[o]._cr_sort = r.colReorder[o]; r.columns.sort(function (t, e) { return t._cr_sort - e._cr_sort }) } } }), u(h).on("preInit.dt", function (t, e) { var r, o; "dt" === t.namespace && (t = e.oInit.colReorder, o = n.defaults.colReorder, t || o) && (r = u.extend({}, o, t), !1 !== t) && (o = new n.Api(e), new b(o, r)) }), n
});
/*! FixedHeader 4.0.1
* © SpryMedia Ltd - datatables.net/license
*/
!function (o) { var i, s; "function" == typeof define && define.amd ? define(["jquery", "datatables.net"], function (t) { return o(t, window, document) }) : "object" == typeof exports ? (i = require("jquery"), s = function (t, e) { e.fn.dataTable || require("datatables.net")(t, e) }, "undefined" == typeof window ? module.exports = function (t, e) { return t = t || window, e = e || i(t), s(t, e), o(e, t, t.document) } : (s(window, i), module.exports = o(i, window, window.document))) : o(jQuery, window, document) }(function (b, m, v) { "use strict"; function s(t, e) { if (!d.versionCheck("2")) throw "Warning: FixedHeader requires DataTables 2 or newer"; if (!(this instanceof s)) throw "FixedHeader must be initialised with the 'new' keyword."; if (!0 === e && (e = {}), t = new d.Api(t), this.c = b.extend(!0, {}, s.defaults, e), this.s = { dt: t, position: { theadTop: 0, tbodyTop: 0, tfootTop: 0, tfootBottom: 0, width: 0, left: 0, tfootHeight: 0, theadHeight: 0, windowHeight: b(m).height(), visible: !0 }, headerMode: null, footerMode: null, autoWidth: t.settings()[0].oFeatures.bAutoWidth, namespace: ".dtfc" + o++, scrollLeft: { header: -1, footer: -1 }, enable: !0, autoDisable: !1 }, this.dom = { floatingHeader: null, thead: b(t.table().header()), tbody: b(t.table().body()), tfoot: b(t.table().footer()), header: { host: null, floating: null, floatingParent: b('<div class="dtfh-floatingparent"><div></div></div>'), placeholder: null }, footer: { host: null, floating: null, floatingParent: b('<div class="dtfh-floatingparent"><div></div></div>'), placeholder: null } }, this.dom.header.host = this.dom.thead.parent(), this.dom.footer.host = this.dom.tfoot.parent(), (e = t.settings()[0])._fixedHeader) throw "FixedHeader already initialised on table " + e.nTable.id; (e._fixedHeader = this)._constructor() } var d = b.fn.dataTable, o = 0; return b.extend(s.prototype, { destroy: function () { var t = this.dom; this.s.dt.off(".dtfc"), b(m).off(this.s.namespace), t.header.rightBlocker && t.header.rightBlocker.remove(), t.header.leftBlocker && t.header.leftBlocker.remove(), t.footer.rightBlocker && t.footer.rightBlocker.remove(), t.footer.leftBlocker && t.footer.leftBlocker.remove(), this.c.header && this._modeChange("in-place", "header", !0), this.c.footer && t.tfoot.length && this._modeChange("in-place", "footer", !0) }, enable: function (t, e, o) { this.s.enable = t, this.s.enableType = o, !e && void 0 !== e || (this._positions(), this._scroll(!0)) }, enabled: function () { return this.s.enable }, headerOffset: function (t) { return void 0 !== t && (this.c.headerOffset = t, this.update()), this.c.headerOffset }, footerOffset: function (t) { return void 0 !== t && (this.c.footerOffset = t, this.update()), this.c.footerOffset }, update: function (t) { var e = this.s.dt.table().node(); (this.s.enable || this.s.autoDisable) && (b(e).is(":visible") ? (this.s.autoDisable = !1, this.enable(!0, !1)) : (this.s.autoDisable = !0, this.enable(!1, !1)), 0 !== b(e).children("thead").length) && (this._positions(), this._scroll(void 0 === t || t), this._widths(this.dom.header), this._widths(this.dom.footer)) }, _constructor: function () { var o = this, i = this.s.dt, t = (b(m).on("scroll" + this.s.namespace, function () { o._scroll() }).on("resize" + this.s.namespace, d.util.throttle(function () { o.s.position.windowHeight = b(m).height(), o.update() }, 50)), b(".fh-fixedHeader")), t = (!this.c.headerOffset && t.length && (this.c.headerOffset = t.outerHeight()), b(".fh-fixedFooter")); !this.c.footerOffset && t.length && (this.c.footerOffset = t.outerHeight()), i.on("column-reorder.dt.dtfc column-visibility.dt.dtfc column-sizing.dt.dtfc responsive-display.dt.dtfc", function (t, e) { o.update() }).on("draw.dt.dtfc", function (t, e) { o.update(e !== i.settings()[0]) }), i.on("destroy.dtfc", function () { o.destroy() }), this._positions(), this._scroll() }, _clone: function (t, e) { var o, i, s = this, d = this.s.dt, n = this.dom[t], r = "header" === t ? this.dom.thead : this.dom.tfoot; "footer" === t && this._scrollEnabled() || (!e && n.floating ? n.floating.removeClass("fixedHeader-floating fixedHeader-locked") : (n.floating && (null !== n.placeholder && n.placeholder.remove(), n.floating.children().detach(), n.floating.remove()), e = b(d.table().node()), o = b(e.parent()), i = this._scrollEnabled(), n.floating = b(d.table().node().cloneNode(!1)).attr("aria-hidden", "true").css({ top: 0, left: 0 }).removeAttr("id"), n.floatingParent.css({ width: o[0].offsetWidth, overflow: "hidden", height: "fit-content", position: "fixed", left: i ? e.offset().left + o.scrollLeft() : 0 }).css("header" === t ? { top: this.c.headerOffset, bottom: "" } : { top: "", bottom: this.c.footerOffset }).addClass("footer" === t ? "dtfh-floatingparent-foot" : "dtfh-floatingparent-head").appendTo("body").children().eq(0).append(n.floating), this._stickyPosition(n.floating, "-"), (i = function () { var t = o.scrollLeft(); s.s.scrollLeft = { footer: t, header: t }, n.floatingParent.scrollLeft(s.s.scrollLeft.header) })(), o.off("scroll.dtfh").on("scroll.dtfh", i), n.floatingParent.children().css({ width: "fit-content", paddingRight: s.s.dt.settings()[0].oBrowser.barWidth }), (e = b("footer" === t ? "div.dtfc-bottom-blocker" : "div.dtfc-top-blocker", d.table().container())).length && e.clone().appendTo(n.floatingParent).css({ position: "fixed", right: e.width() }), n.placeholder = r.clone(!1), n.placeholder.find("*[id]").removeAttr("id"), n.host.prepend(n.placeholder), n.floating.append(r), this._widths(n))) }, _stickyPosition: function (t, e) { var i; this._scrollEnabled() && (i = "rtl" === b(this.s.dt.table().node()).css("direction"), t.find("th").each(function () { var t, e, o; "sticky" === b(this).css("position") && (t = b(this).css("right"), e = b(this).css("left"), "auto" === t || i ? "auto" !== e && i && (o = +e.replace(/px/g, ""), b(this).css("left", 0 < o ? o : 0)) : (o = +t.replace(/px/g, ""), b(this).css("right", 0 < o ? o : 0))) })) }, _horizontal: function (t, e) { var o, i = this.dom[t], s = this.s.scrollLeft; i.floating && s[t] !== e && (this._scrollEnabled() && (o = b(b(this.s.dt.table().node()).parent()).scrollLeft(), i.floating.scrollLeft(o), i.floatingParent.scrollLeft(o)), s[t] = e) }, _modeChange: function (t, e, o) { var i, s, d, n, r, a, f, h = this.dom[e], l = this.s.position, c = this._scrollEnabled(); "footer" === e && c || (i = function (t) { h.floating[0].style.setProperty("width", t + "px", "important"), c || h.floatingParent[0].style.setProperty("width", t + "px", "important") }, n = this.dom["footer" === e ? "tfoot" : "thead"], s = b.contains(n[0], v.activeElement) ? v.activeElement : null, r = b(b(this.s.dt.table().node()).parent()), "in-place" === t ? (h.placeholder && (h.placeholder.remove(), h.placeholder = null), "header" === e ? h.host.prepend(n) : h.host.append(n), h.floating && (h.floating.remove(), h.floating = null, this._stickyPosition(h.host, "+")), h.floatingParent && (h.floatingParent.find("div.dtfc-top-blocker").remove(), h.floatingParent.remove()), b(b(h.host.parent()).parent()).scrollLeft(r.scrollLeft())) : "in" === t ? (this._clone(e, o), n = r.offset(), f = (d = b(v).scrollTop()) + b(m).height(), a = c ? n.top : l.tbodyTop, n = c ? n.top + r.outerHeight() : l.tfootTop, r = "footer" === e ? f < a ? l.tfootHeight : a + l.tfootHeight - f : d + this.c.headerOffset + l.theadHeight - n, a = "header" === e ? "top" : "bottom", f = this.c[e + "Offset"] - (0 < r ? r : 0), h.floating.addClass("fixedHeader-floating"), h.floatingParent.css(a, f).css({ left: l.left, "z-index": 3 }), i(l.width), "footer" === e && h.floating.css("top", "")) : "below" === t ? (this._clone(e, o), h.floating.addClass("fixedHeader-locked"), h.floatingParent.css({ position: "absolute", top: l.tfootTop - l.theadHeight, left: l.left + "px" }), i(l.width)) : "above" === t && (this._clone(e, o), h.floating.addClass("fixedHeader-locked"), h.floatingParent.css({ position: "absolute", top: l.tbodyTop, left: l.left + "px" }), i(l.width)), s && s !== v.activeElement && setTimeout(function () { s.focus() }, 10), this.s.scrollLeft.header = -1, this.s.scrollLeft.footer = -1, this.s[e + "Mode"] = t) }, _positions: function () { var t = this.s.dt, e = t.table(), o = this.s.position, i = this.dom, e = b(e.node()), s = this._scrollEnabled(), d = b(t.table().header()), t = b(t.table().footer()), i = i.tbody, n = e.parent(); o.visible = e.is(":visible"), o.width = e.outerWidth(), o.left = e.offset().left, o.theadTop = d.offset().top, o.tbodyTop = (s ? n : i).offset().top, o.tbodyHeight = (s ? n : i).outerHeight(), o.theadHeight = d.outerHeight(), o.theadBottom = o.theadTop + o.theadHeight, o.tfootTop = o.tbodyTop + o.tbodyHeight, t.length ? (o.tfootBottom = o.tfootTop + t.outerHeight(), o.tfootHeight = t.outerHeight()) : (o.tfootBottom = o.tfootTop, o.tfootHeight = 0) }, _scroll: function (t) { var e, o, i, s, d, n, r, a, f, h, l, c, p, g, u; this.s.dt.settings()[0].bDestroying || (e = this._scrollEnabled(), i = (o = b(this.s.dt.table().node()).parent()).offset(), h = o.outerHeight(), s = b(v).scrollLeft(), d = b(v).scrollTop(), n = b(m).height() + d, l = this.s.position, c = e ? i.top : l.tbodyTop, a = (e ? i : l).left, h = e ? i.top + h : l.tfootTop, f = e ? o.outerWidth() : l.tbodyWidth, this.c.header && (!this.s.enable || !l.visible || d + this.c.headerOffset + l.theadHeight <= c ? r = "in-place" : d + this.c.headerOffset + l.theadHeight > c && d + this.c.headerOffset + l.theadHeight < h ? (r = "in", d + this.c.headerOffset + l.theadHeight > h || void 0 === this.dom.header.floatingParent ? t = !0 : this.dom.header.floatingParent.css({ top: this.c.headerOffset, position: "fixed" }).children().eq(0).append(this.dom.header.floating)) : r = "below", !t && r === this.s.headerMode || this._modeChange(r, "header", t), this._horizontal("header", s)), p = { offset: { top: 0, left: 0 }, height: 0 }, g = { offset: { top: 0, left: 0 }, height: 0 }, this.c.footer && this.dom.tfoot.length && this.dom.tfoot.find("th, td").length && (!this.s.enable || !l.visible || l.tfootBottom + this.c.footerOffset <= n ? u = "in-place" : h + l.tfootHeight + this.c.footerOffset > n && c + this.c.footerOffset < n ? (u = "in", t = !0) : u = "above", !t && u === this.s.footerMode || this._modeChange(u, "footer", t), this._horizontal("footer", s), h = function (t) { return { offset: t.offset(), height: t.outerHeight() } }, p = this.dom.header.floating ? h(this.dom.header.floating) : h(this.dom.thead), g = this.dom.footer.floating ? h(this.dom.footer.floating) : h(this.dom.tfoot), e) && g.offset.top > d && (c = n + ((l = d - i.top) > -p.height ? l : 0) - (p.offset.top + (l < -p.height ? p.height : 0) + g.height), o.outerHeight(c = c < 0 ? 0 : c), Math.round(o.outerHeight()) >= Math.round(c) ? b(this.dom.tfoot.parent()).addClass("fixedHeader-floating") : b(this.dom.tfoot.parent()).removeClass("fixedHeader-floating")), this.dom.header.floating && this.dom.header.floatingParent.css("left", a - s), this.dom.footer.floating && this.dom.footer.floatingParent.css("left", a - s), void 0 !== this.s.dt.settings()[0]._fixedColumns && (this.dom.header.rightBlocker = (u = function (t, e, o) { var i; return null !== (o = void 0 === o ? 0 === (i = b("div.dtfc-" + t + "-" + e + "-blocker")).length ? null : i.clone().css("z-index", 1) : o) && ("in" === r || "below" === r ? o.appendTo("body").css({ top: ("top" === e ? p : g).offset.top, left: "right" === t ? a + f - o.width() : a }) : o.detach()), o })("right", "top", this.dom.header.rightBlocker), this.dom.header.leftBlocker = u("left", "top", this.dom.header.leftBlocker), this.dom.footer.rightBlocker = u("right", "bottom", this.dom.footer.rightBlocker), this.dom.footer.leftBlocker = u("left", "bottom", this.dom.footer.leftBlocker))) }, _scrollEnabled: function () { var t = this.s.dt.settings()[0].oScroll; return "" !== t.sY || "" !== t.sX }, _widths: function (t) { if (t && t.placeholder) for (var e = b(this.s.dt.table().node()), o = b(e.parent()), i = (t.floatingParent.css("width", o[0].offsetWidth), t.floating.css("width", e[0].offsetWidth), b("colgroup", t.floating).remove(), t.placeholder.parent().find("colgroup").clone().appendTo(t.floating).find("col")), s = this.s.dt.columns(":visible").widths(), d = 0; d < s.length; d++)i.eq(d).css("width", s[d]) } }), s.version = "4.0.1", s.defaults = { header: !0, footer: !1, headerOffset: 0, footerOffset: 0 }, b.fn.dataTable.FixedHeader = s, b.fn.DataTable.FixedHeader = s, b(v).on("init.dt.dtfh", function (t, e, o) { var i; "dt" === t.namespace && (t = e.oInit.fixedHeader, i = d.defaults.fixedHeader, t || i) && !e._fixedHeader && (i = b.extend({}, i, t), !1 !== t) && new s(e, i) }), d.Api.register("fixedHeader()", function () { }), d.Api.register("fixedHeader.adjust()", function () { return this.iterator("table", function (t) { t = t._fixedHeader; t && t.update() }) }), d.Api.register("fixedHeader.enable()", function (e) { return this.iterator("table", function (t) { t = t._fixedHeader; e = void 0 === e || e, t && e !== t.enabled() && t.enable(e) }) }), d.Api.register("fixedHeader.enabled()", function () { if (this.context.length) { var t = this.context[0]._fixedHeader; if (t) return t.enabled() } return !1 }), d.Api.register("fixedHeader.disable()", function () { return this.iterator("table", function (t) { t = t._fixedHeader; t && t.enabled() && t.enable(!1) }) }), b.each(["header", "footer"], function (t, o) { d.Api.register("fixedHeader." + o + "Offset()", function (e) { var t = this.context; return void 0 === e ? t.length && t[0]._fixedHeader ? t[0]._fixedHeader[o + "Offset"]() : void 0 : this.iterator("table", function (t) { t = t._fixedHeader; t && t[o + "Offset"](e) }) }) }), d });
/*!
 * Column visibility buttons for Buttons and DataTables.
 * © SpryMedia Ltd - datatables.net/license
 */
!function (i) { var o, e; "function" == typeof define && define.amd ? define(["jquery", "datatables.net", "datatables.net-buttons"], function (n) { return i(n, window, document) }) : "object" == typeof exports ? (o = require("jquery"), e = function (n, t) { t.fn.dataTable || require("datatables.net")(n, t), t.fn.dataTable.Buttons || require("datatables.net-buttons")(n, t) }, "undefined" == typeof window ? module.exports = function (n, t) { return n = n || window, t = t || o(n), e(n, t), i(t, 0, n.document) } : (e(window, o), module.exports = i(o, window, window.document))) : i(jQuery, window, document) }(function (n, t, i) { "use strict"; var e = n.fn.dataTable; return n.extend(e.ext.buttons, { colvis: function (n, t) { var i = null, o = { extend: "collection", init: function (n, t) { i = t }, text: function (n) { return n.i18n("buttons.colvis", "Column visibility") }, className: "buttons-colvis", closeButton: !1, buttons: [{ extend: "columnsToggle", columns: t.columns, columnText: t.columnText }] }; return n.on("column-reorder.dt" + t.namespace, function () { n.button(null, n.button(null, i).node()).collectionRebuild([{ extend: "columnsToggle", columns: t.columns, columnText: t.columnText }]) }), o }, columnsToggle: function (n, t) { return n.columns(t.columns).indexes().map(function (n) { return { extend: "columnToggle", columns: n, columnText: t.columnText } }).toArray() }, columnToggle: function (n, t) { return { extend: "columnVisibility", columns: t.columns, columnText: t.columnText } }, columnsVisibility: function (n, t) { return n.columns(t.columns).indexes().map(function (n) { return { extend: "columnVisibility", columns: n, visibility: t.visibility, columnText: t.columnText } }).toArray() }, columnVisibility: { columns: void 0, text: function (n, t, i) { return i._columnText(n, i) }, className: "buttons-columnVisibility", action: function (n, t, i, o) { var t = t.columns(o.columns), e = t.visible(); t.visible(void 0 !== o.visibility ? o.visibility : !(e.length && e[0])) }, init: function (i, n, o) { var e = this; n.attr("data-cv-idx", o.columns), i.on("column-visibility.dt" + o.namespace, function (n, t) { t.bDestroying || t.nTable != i.settings()[0].nTable || e.active(i.column(o.columns).visible()) }).on("column-reorder.dt" + o.namespace, function () { o.destroying || 1 === i.columns(o.columns).count() && (e.text(o._columnText(i, o)), e.active(i.column(o.columns).visible())) }), this.active(i.column(o.columns).visible()) }, destroy: function (n, t, i) { n.off("column-visibility.dt" + i.namespace).off("column-reorder.dt" + i.namespace) }, _columnText: function (n, t) { var i, o; return "string" == typeof t.text ? t.text : (o = n.column(t.columns).title(), i = n.column(t.columns).index(), o = o.replace(/\n/g, " ").replace(/<br\s*\/?>/gi, " ").replace(/<select(.*?)<\/select\s*>/gi, ""), o = e.Buttons.stripHtmlComments(o), o = e.util.stripHtml(o).trim(), t.columnText ? t.columnText(n, i, o) : o) } }, colvisRestore: { className: "buttons-colvisRestore", text: function (n) { return n.i18n("buttons.colvisRestore", "Restore visibility") }, init: function (n, t, i) { n.columns().every(function () { var n = this.init(); void 0 === n.__visOriginal && (n.__visOriginal = this.visible()) }) }, action: function (n, t, i, o) { t.columns().every(function (n) { var t = this.init(); this.visible(t.__visOriginal) }) } }, colvisGroup: { className: "buttons-colvisGroup", action: function (n, t, i, o) { t.columns(o.show).visible(!0, !1), t.columns(o.hide).visible(!1, !1), t.columns.adjust() }, show: [], hide: [] } }), e });
/*! RowGroup 1.5.0
 * © SpryMedia Ltd - datatables.net/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        var jq = require('jquery');
        var cjsRequires = function (root, $) {
            if (!$.fn.dataTable) {
                require('datatables.net')(root, $);
            }
        };

        if (typeof window === 'undefined') {
            module.exports = function (root, $) {
                if (!root) {
                    // CommonJS environments without a window global must pass a
                    // root. This will give an error otherwise
                    root = window;
                }

                if (!$) {
                    $ = jq(root);
                }

                cjsRequires(root, $);
                return factory($, root, root.document);
            };
        }
        else {
            cjsRequires(window, jq);
            module.exports = factory(jq, window, window.document);
        }
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;



    /**
     * @summary     RowGroup
     * @description RowGrouping for DataTables
     * @version     1.5.0
     * @author      SpryMedia Ltd (www.sprymedia.co.uk)
     * @contact     datatables.net
     * @copyright   SpryMedia Ltd.
     *
     * This source file is free software, available under the following license:
     *   MIT license - http://datatables.net/license/mit
     *
     * This source file is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
     *
     * For details please refer to: http://www.datatables.net
     */

    var RowGroup = function (dt, opts) {
        // Sanity check that we are using DataTables 1.10 or newer
        if (!DataTable.versionCheck || !DataTable.versionCheck('1.11')) {
            throw 'RowGroup requires DataTables 1.11 or newer';
        }

        // User and defaults configuration object
        this.c = $.extend(true, {}, DataTable.defaults.rowGroup, RowGroup.defaults, opts);

        // Internal settings
        this.s = {
            dt: new DataTable.Api(dt)
        };

        // DOM items
        this.dom = {};

        // Check if row grouping has already been initialised on this table
        var settings = this.s.dt.settings()[0];
        var existing = settings.rowGroup;
        if (existing) {
            return existing;
        }

        settings.rowGroup = this;
        this._constructor();
    };

    $.extend(RowGroup.prototype, {
        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * API methods for DataTables API interface
         */

        /**
         * Get/set the grouping data source - need to call draw after this is
         * executed as a setter
         * @returns string~RowGroup
         */
        dataSrc: function (val) {
            if (val === undefined) {
                return this.c.dataSrc;
            }

            var dt = this.s.dt;

            this.c.dataSrc = val;

            $(dt.table().node()).triggerHandler('rowgroup-datasrc.dt', [dt, val]);

            return this;
        },

        /**
         * Disable - need to call draw after this is executed
         * @returns RowGroup
         */
        disable: function () {
            this.c.enable = false;
            return this;
        },

        /**
         * Enable - need to call draw after this is executed
         * @returns RowGroup
         */
        enable: function (flag) {
            if (flag === false) {
                return this.disable();
            }

            this.c.enable = true;
            return this;
        },

        /**
         * Get enabled flag
         * @returns boolean
         */
        enabled: function () {
            return this.c.enable;
        },

        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Constructor
         */
        _constructor: function () {
            var that = this;
            var dt = this.s.dt;
            var hostSettings = dt.settings()[0];

            dt.on('draw.dtrg', function (e, s) {
                if (that.c.enable && hostSettings === s) {
                    that._draw();
                }
            });

            dt.on('column-visibility.dt.dtrg responsive-resize.dt.dtrg', function () {
                that._adjustColspan();
            });

            dt.on('destroy', function () {
                dt.off('.dtrg');
            });
        },

        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         * Private methods
         */

        /**
         * Adjust column span when column visibility changes
         * @private
         */
        _adjustColspan: function () {
            $('tr.' + this.c.className, this.s.dt.table().body())
                .find('th:visible, td:visible')
                .attr('colspan', this._colspan());
        },

        /**
         * Get the number of columns that a grouping row should span
         * @private
         */
        _colspan: function () {
            return this.s.dt
                .columns()
                .visible()
                .reduce(function (a, b) {
                    return a + b;
                }, 0);
        },

        /**
         * Update function that is called whenever we need to draw the grouping rows.
         * This is basically a bootstrap for the self iterative _group and _groupDisplay
         * methods
         * @private
         */
        _draw: function () {
            var dt = this.s.dt;
            var groupedRows = this._group(0, dt.rows({ page: 'current' }).indexes());

            this._groupDisplay(0, groupedRows);
        },

        /**
         * Get the grouping information from a data set (index) of rows
         * @param {number} level Nesting level
         * @param {DataTables.Api} rows API of the rows to consider for this group
         * @returns {object[]} Nested grouping information - it is structured like this:
         *	{
         *		dataPoint: 'Edinburgh',
         *		rows: [ 1,2,3,4,5,6,7 ],
         *		children: [ {
         *			dataPoint: 'developer'
         *			rows: [ 1, 2, 3 ]
         *		},
         *		{
         *			dataPoint: 'support',
         *			rows: [ 4, 5, 6, 7 ]
         *		} ]
         *	}
         * @private
         */
        _group: function (level, rows) {
            var fns = Array.isArray(this.c.dataSrc) ? this.c.dataSrc : [this.c.dataSrc];
            var fn = DataTable.util.get(fns[level]);
            var dt = this.s.dt;
            var group, last;
            var i, ien;
            var data = [];
            var that = this;

            for (i = 0, ien = rows.length; i < ien; i++) {
                var rowIndex = rows[i];
                var rowData = dt.row(rowIndex).data();

                group = fn(rowData, level);

                if (group === null || group === undefined) {
                    group = that.c.emptyDataGroup;
                }

                if (last === undefined || group !== last) {
                    data.push({
                        dataPoint: group,
                        rows: []
                    });

                    last = group;
                }

                data[data.length - 1].rows.push(rowIndex);
            }

            if (fns[level + 1] !== undefined) {
                for (i = 0, ien = data.length; i < ien; i++) {
                    data[i].children = this._group(level + 1, data[i].rows);
                }
            }

            return data;
        },

        /**
         * Row group display - insert the rows into the document
         * @param {number} level Nesting level
         * @param {object[]} groups Takes the nested array from `_group`
         * @private
         */
        _groupDisplay: function (level, groups) {
            var dt = this.s.dt;
            var display;

            for (var i = 0, ien = groups.length; i < ien; i++) {
                var group = groups[i];
                var groupName = group.dataPoint;
                var row;
                var rows = group.rows;

                if (this.c.startRender) {
                    display = this.c.startRender.call(this, dt.rows(rows), groupName, level);
                    row = this._rowWrap(display, this.c.startClassName, level);

                    if (row) {
                        row.insertBefore(dt.row(rows[0]).node());
                    }
                }

                if (this.c.endRender) {
                    display = this.c.endRender.call(this, dt.rows(rows), groupName, level);
                    row = this._rowWrap(display, this.c.endClassName, level);

                    if (row) {
                        row.insertAfter(dt.row(rows[rows.length - 1]).node());
                    }
                }

                if (group.children) {
                    this._groupDisplay(level + 1, group.children);
                }
            }
        },

        /**
         * Take a rendered value from an end user and make it suitable for display
         * as a row, by wrapping it in a row, or detecting that it is a row.
         * @param {node|jQuery|string} display Display value
         * @param {string} className Class to add to the row
         * @param {array} group
         * @param {number} group level
         * @private
         */
        _rowWrap: function (display, className, level) {
            var row;

            if (display === null || display === '') {
                display = this.c.emptyDataGroup;
            }

            if (display === undefined || display === null) {
                return null;
            }

            if (
                typeof display === 'object' &&
                display.nodeName &&
                display.nodeName.toLowerCase() === 'tr'
            ) {
                row = $(display);
            }
            else if (
                display instanceof $ &&
                display.length &&
                display[0].nodeName.toLowerCase() === 'tr'
            ) {
                row = display;
            }
            else {
                row = $('<tr/>').append(
                    $('<th/>').attr('colspan', this._colspan()).attr('scope', 'row').append(display)
                );
            }

            return row
                .addClass(this.c.className)
                .addClass(className)
                .addClass('dtrg-level-' + level);
        }
    });

    /**
     * RowGroup default settings for initialisation
     *
     * @namespace
     * @name RowGroup.defaults
     * @static
     */
    RowGroup.defaults = {
        /**
         * Class to apply to grouping rows - applied to both the start and
         * end grouping rows.
         * @type string
         */
        className: 'dtrg-group',

        /**
         * Data property from which to read the grouping information
         * @type string|integer|array
         */
        dataSrc: 0,

        /**
         * Text to show if no data is found for a group
         * @type string
         */
        emptyDataGroup: 'No group',

        /**
         * Initial enablement state
         * @boolean
         */
        enable: true,

        /**
         * Class name to give to the end grouping row
         * @type string
         */
        endClassName: 'dtrg-end',

        /**
         * End grouping label function
         * @function
         */
        endRender: null,

        /**
         * Class name to give to the start grouping row
         * @type string
         */
        startClassName: 'dtrg-start',

        /**
         * Start grouping label function
         * @function
         */
        startRender: function (rows, group) {
            return group;
        }
    };

    RowGroup.version = '1.5.0';

    $.fn.dataTable.RowGroup = RowGroup;
    $.fn.DataTable.RowGroup = RowGroup;

    DataTable.Api.register('rowGroup()', function () {
        return this;
    });

    DataTable.Api.register('rowGroup().disable()', function () {
        return this.iterator('table', function (ctx) {
            if (ctx.rowGroup) {
                ctx.rowGroup.enable(false);
            }
        });
    });

    DataTable.Api.register('rowGroup().enable()', function (opts) {
        return this.iterator('table', function (ctx) {
            if (ctx.rowGroup) {
                ctx.rowGroup.enable(opts === undefined ? true : opts);
            }
        });
    });

    DataTable.Api.register('rowGroup().enabled()', function () {
        var ctx = this.context;

        return ctx.length && ctx[0].rowGroup ? ctx[0].rowGroup.enabled() : false;
    });

    DataTable.Api.register('rowGroup().dataSrc()', function (val) {
        if (val === undefined) {
            return this.context[0].rowGroup.dataSrc();
        }

        return this.iterator('table', function (ctx) {
            if (ctx.rowGroup) {
                ctx.rowGroup.dataSrc(val);
            }
        });
    });

    // Attach a listener to the document which listens for DataTables initialisation
    // events so we can automatically initialise
    $(document).on('preInit.dt.dtrg', function (e, settings, json) {
        if (e.namespace !== 'dt') {
            return;
        }

        var init = settings.oInit.rowGroup;
        var defaults = DataTable.defaults.rowGroup;

        if (init || defaults) {
            var opts = $.extend({}, defaults, init);

            if (init !== false) {
                new RowGroup(settings, opts);
            }
        }
    });


    return DataTable;
}));
/*! DataTables styling wrapper for RowGroup
 * © SpryMedia Ltd - datatables.net/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net-dt', 'datatables.net-rowgroup'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        var jq = require('jquery');
        var cjsRequires = function (root, $) {
            if (!$.fn.dataTable) {
                require('datatables.net-dt')(root, $);
            }

            if (!$.fn.dataTable.RowGroup) {
                require('datatables.net-rowgroup')(root, $);
            }
        };

        if (typeof window === 'undefined') {
            module.exports = function (root, $) {
                if (!root) {
                    // CommonJS environments without a window global must pass a
                    // root. This will give an error otherwise
                    root = window;
                }

                if (!$) {
                    $ = jq(root);
                }

                cjsRequires(root, $);
                return factory($, root, root.document);
            };
        }
        else {
            cjsRequires(window, jq);
            module.exports = factory(jq, window, window.document);
        }
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;
    return DataTable;
}));
/*! Select for DataTables 2.0.5
 * © SpryMedia Ltd - datatables.net/license/mit
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        var jq = require('jquery');
        var cjsRequires = function (root, $) {
            if (!$.fn.dataTable) {
                require('datatables.net')(root, $);
            }
        };

        if (typeof window === 'undefined') {
            module.exports = function (root, $) {
                if (!root) {
                    // CommonJS environments without a window global must pass a
                    // root. This will give an error otherwise
                    root = window;
                }

                if (!$) {
                    $ = jq(root);
                }

                cjsRequires(root, $);
                return factory($, root, root.document);
            };
        }
        else {
            cjsRequires(window, jq);
            module.exports = factory(jq, window, window.document);
        }
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;



    // Version information for debugger
    DataTable.select = {};

    DataTable.select.classes = {
        checkbox: 'dt-select-checkbox'
    };

    DataTable.select.version = '2.0.5';

    DataTable.select.init = function (dt) {
        var ctx = dt.settings()[0];

        if (!DataTable.versionCheck('2')) {
            throw 'Warning: Select requires DataTables 2 or newer';
        }

        if (ctx._select) {
            return;
        }

        var savedSelected = dt.state.loaded();

        var selectAndSave = function (e, settings, data) {
            if (data === null || data.select === undefined) {
                return;
            }

            // Clear any currently selected rows, before restoring state
            // None will be selected on first initialisation
            if (dt.rows({ selected: true }).any()) {
                dt.rows().deselect();
            }
            if (data.select.rows !== undefined) {
                dt.rows(data.select.rows).select();
            }

            if (dt.columns({ selected: true }).any()) {
                dt.columns().deselect();
            }
            if (data.select.columns !== undefined) {
                dt.columns(data.select.columns).select();
            }

            if (dt.cells({ selected: true }).any()) {
                dt.cells().deselect();
            }
            if (data.select.cells !== undefined) {
                for (var i = 0; i < data.select.cells.length; i++) {
                    dt.cell(data.select.cells[i].row, data.select.cells[i].column).select();
                }
            }

            dt.state.save();
        };

        dt.on('stateSaveParams', function (e, settings, data) {
            data.select = {};
            data.select.rows = dt.rows({ selected: true }).ids(true).toArray();
            data.select.columns = dt.columns({ selected: true })[0];
            data.select.cells = dt.cells({ selected: true })[0].map(function (coords) {
                return { row: dt.row(coords.row).id(true), column: coords.column };
            });
        })
            .on('stateLoadParams', selectAndSave)
            .one('init', function () {
                selectAndSave(undefined, undefined, savedSelected);
            });

        var init = ctx.oInit.select;
        var defaults = DataTable.defaults.select;
        var opts = init === undefined ? defaults : init;

        // Set defaults
        var items = 'row';
        var style = 'api';
        var blurable = false;
        var toggleable = true;
        var info = true;
        var selector = 'td, th';
        var className = 'selected';
        var headerCheckbox = true;
        var setStyle = false;

        ctx._select = {
            infoEls: []
        };

        // Initialisation customisations
        if (opts === true) {
            style = 'os';
            setStyle = true;
        }
        else if (typeof opts === 'string') {
            style = opts;
            setStyle = true;
        }
        else if ($.isPlainObject(opts)) {
            if (opts.blurable !== undefined) {
                blurable = opts.blurable;
            }

            if (opts.toggleable !== undefined) {
                toggleable = opts.toggleable;
            }

            if (opts.info !== undefined) {
                info = opts.info;
            }

            if (opts.items !== undefined) {
                items = opts.items;
            }

            if (opts.style !== undefined) {
                style = opts.style;
                setStyle = true;
            }
            else {
                style = 'os';
                setStyle = true;
            }

            if (opts.selector !== undefined) {
                selector = opts.selector;
            }

            if (opts.className !== undefined) {
                className = opts.className;
            }

            if (opts.headerCheckbox !== undefined) {
                headerCheckbox = opts.headerCheckbox;
            }
        }

        dt.select.selector(selector);
        dt.select.items(items);
        dt.select.style(style);
        dt.select.blurable(blurable);
        dt.select.toggleable(toggleable);
        dt.select.info(info);
        ctx._select.className = className;

        // If the init options haven't enabled select, but there is a selectable
        // class name, then enable
        if (!setStyle && $(dt.table().node()).hasClass('selectable')) {
            dt.select.style('os');
        }

        // Insert a checkbox into the header if needed - might need to wait
        // for init complete, or it might already be done
        if (headerCheckbox || headerCheckbox === 'select-page' || headerCheckbox === 'select-all') {
            initCheckboxHeader(dt, headerCheckbox);

            dt.on('init', function () {
                initCheckboxHeader(dt, headerCheckbox);
            });
        }
    };

    /*
    
    Select is a collection of API methods, event handlers, event emitters and
    buttons (for the `Buttons` extension) for DataTables. It provides the following
    features, with an overview of how they are implemented:
    
    ## Selection of rows, columns and cells. Whether an item is selected or not is
       stored in:
    
    * rows: a `_select_selected` property which contains a boolean value of the
      DataTables' `aoData` object for each row
    * columns: a `_select_selected` property which contains a boolean value of the
      DataTables' `aoColumns` object for each column
    * cells: a `_selected_cells` property which contains an array of boolean values
      of the `aoData` object for each row. The array is the same length as the
      columns array, with each element of it representing a cell.
    
    This method of using boolean flags allows Select to operate when nodes have not
    been created for rows / cells (DataTables' defer rendering feature).
    
    ## API methods
    
    A range of API methods are available for triggering selection and de-selection
    of rows. Methods are also available to configure the selection events that can
    be triggered by an end user (such as which items are to be selected). To a large
    extent, these of API methods *is* Select. It is basically a collection of helper
    functions that can be used to select items in a DataTable.
    
    Configuration of select is held in the object `_select` which is attached to the
    DataTables settings object on initialisation. Select being available on a table
    is not optional when Select is loaded, but its default is for selection only to
    be available via the API - so the end user wouldn't be able to select rows
    without additional configuration.
    
    The `_select` object contains the following properties:
    
    ```
    {
        items:string       - Can be `rows`, `columns` or `cells`. Defines what item 
                             will be selected if the user is allowed to activate row
                             selection using the mouse.
        style:string       - Can be `none`, `single`, `multi` or `os`. Defines the
                             interaction style when selecting items
        blurable:boolean   - If row selection can be cleared by clicking outside of
                             the table
        toggleable:boolean - If row selection can be cancelled by repeated clicking
                             on the row
        info:boolean       - If the selection summary should be shown in the table
                             information elements
        infoEls:element[]  - List of HTML elements with info elements for a table
    }
    ```
    
    In addition to the API methods, Select also extends the DataTables selector
    options for rows, columns and cells adding a `selected` option to the selector
    options object, allowing the developer to select only selected items or
    unselected items.
    
    ## Mouse selection of items
    
    Clicking on items can be used to select items. This is done by a simple event
    handler that will select the items using the API methods.
    
     */

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Local functions
     */

    /**
     * Add one or more cells to the selection when shift clicking in OS selection
     * style cell selection.
     *
     * Cell range is more complicated than row and column as we want to select
     * in the visible grid rather than by index in sequence. For example, if you
     * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1
     * should also be selected (and not 1-3, 1-4. etc)
     *
     * @param  {DataTable.Api} dt   DataTable
     * @param  {object}        idx  Cell index to select to
     * @param  {object}        last Cell index to select from
     * @private
     */
    function cellRange(dt, idx, last) {
        var indexes;
        var columnIndexes;
        var rowIndexes;
        var selectColumns = function (start, end) {
            if (start > end) {
                var tmp = end;
                end = start;
                start = tmp;
            }

            var record = false;
            return dt
                .columns(':visible')
                .indexes()
                .filter(function (i) {
                    if (i === start) {
                        record = true;
                    }

                    if (i === end) {
                        // not else if, as start might === end
                        record = false;
                        return true;
                    }

                    return record;
                });
        };

        var selectRows = function (start, end) {
            var indexes = dt.rows({ search: 'applied' }).indexes();

            // Which comes first - might need to swap
            if (indexes.indexOf(start) > indexes.indexOf(end)) {
                var tmp = end;
                end = start;
                start = tmp;
            }

            var record = false;
            return indexes.filter(function (i) {
                if (i === start) {
                    record = true;
                }

                if (i === end) {
                    record = false;
                    return true;
                }

                return record;
            });
        };

        if (!dt.cells({ selected: true }).any() && !last) {
            // select from the top left cell to this one
            columnIndexes = selectColumns(0, idx.column);
            rowIndexes = selectRows(0, idx.row);
        }
        else {
            // Get column indexes between old and new
            columnIndexes = selectColumns(last.column, idx.column);
            rowIndexes = selectRows(last.row, idx.row);
        }

        indexes = dt.cells(rowIndexes, columnIndexes).flatten();

        if (!dt.cells(idx, { selected: true }).any()) {
            // Select range
            dt.cells(indexes).select();
        }
        else {
            // Deselect range
            dt.cells(indexes).deselect();
        }
    }

    /**
     * Get the class
     * @returns 
     */
    function checkboxClass(selector) {
        var name = DataTable.select.classes.checkbox;

        return selector
            ? name.replace(/ /g, '.')
            : name;
    }

    /**
     * Disable mouse selection by removing the selectors
     *
     * @param {DataTable.Api} dt DataTable to remove events from
     * @private
     */
    function disableMouseSelection(dt) {
        var ctx = dt.settings()[0];
        var selector = ctx._select.selector;

        $(dt.table().container())
            .off('mousedown.dtSelect', selector)
            .off('mouseup.dtSelect', selector)
            .off('click.dtSelect', selector);

        $('body').off('click.dtSelect' + _safeId(dt.table().node()));
    }

    /**
     * Attach mouse listeners to the table to allow mouse selection of items
     *
     * @param {DataTable.Api} dt DataTable to remove events from
     * @private
     */
    function enableMouseSelection(dt) {
        var container = $(dt.table().container());
        var ctx = dt.settings()[0];
        var selector = ctx._select.selector;
        var matchSelection;

        container
            .on('mousedown.dtSelect', selector, function (e) {
                // Disallow text selection for shift clicking on the table so multi
                // element selection doesn't look terrible!
                if (e.shiftKey || e.metaKey || e.ctrlKey) {
                    container
                        .css('-moz-user-select', 'none')
                        .one('selectstart.dtSelect', selector, function () {
                            return false;
                        });
                }

                if (window.getSelection) {
                    matchSelection = window.getSelection();
                }
            })
            .on('mouseup.dtSelect', selector, function () {
                // Allow text selection to occur again, Mozilla style (tested in FF
                // 35.0.1 - still required)
                container.css('-moz-user-select', '');
            })
            .on('click.dtSelect', selector, function (e) {
                var items = dt.select.items();
                var idx;

                // If text was selected (click and drag), then we shouldn't change
                // the row's selected state
                if (matchSelection) {
                    var selection = window.getSelection();

                    // If the element that contains the selection is not in the table, we can ignore it
                    // This can happen if the developer selects text from the click event
                    if (
                        !selection.anchorNode ||
                        $(selection.anchorNode).closest('table')[0] === dt.table().node()
                    ) {
                        if (selection !== matchSelection) {
                            return;
                        }
                    }
                }

                var ctx = dt.settings()[0];
                var container = dt.table().container();

                // Ignore clicks inside a sub-table
                if ($(e.target).closest('div.dt-container')[0] != container) {
                    return;
                }

                var cell = dt.cell($(e.target).closest('td, th'));

                // Check the cell actually belongs to the host DataTable (so child
                // rows, etc, are ignored)
                if (!cell.any()) {
                    return;
                }

                var event = $.Event('user-select.dt');
                eventTrigger(dt, event, [items, cell, e]);

                if (event.isDefaultPrevented()) {
                    return;
                }

                var cellIndex = cell.index();
                if (items === 'row') {
                    idx = cellIndex.row;
                    typeSelect(e, dt, ctx, 'row', idx);
                }
                else if (items === 'column') {
                    idx = cell.index().column;
                    typeSelect(e, dt, ctx, 'column', idx);
                }
                else if (items === 'cell') {
                    idx = cell.index();
                    typeSelect(e, dt, ctx, 'cell', idx);
                }

                ctx._select_lastCell = cellIndex;
            });

        // Blurable
        $('body').on('click.dtSelect' + _safeId(dt.table().node()), function (e) {
            if (ctx._select.blurable) {
                // If the click was inside the DataTables container, don't blur
                if ($(e.target).parents().filter(dt.table().container()).length) {
                    return;
                }

                // Ignore elements which have been removed from the DOM (i.e. paging
                // buttons)
                if ($(e.target).parents('html').length === 0) {
                    return;
                }

                // Don't blur in Editor form
                if ($(e.target).parents('div.DTE').length) {
                    return;
                }

                var event = $.Event('select-blur.dt');
                eventTrigger(dt, event, [e.target, e]);

                if (event.isDefaultPrevented()) {
                    return;
                }

                clear(ctx, true);
            }
        });
    }

    /**
     * Trigger an event on a DataTable
     *
     * @param {DataTable.Api} api      DataTable to trigger events on
     * @param  {boolean}      selected true if selected, false if deselected
     * @param  {string}       type     Item type acting on
     * @param  {boolean}      any      Require that there are values before
     *     triggering
     * @private
     */
    function eventTrigger(api, type, args, any) {
        if (any && !api.flatten().length) {
            return;
        }

        if (typeof type === 'string') {
            type = type + '.dt';
        }

        args.unshift(api);

        $(api.table().node()).trigger(type, args);
    }

    /**
     * Determine if a column is a checkbox column
     * @param {*} col DataTables column object
     * @returns 
     */
    function isCheckboxColumn(col) {
        return col.mRender && col.mRender._name === 'selectCheckbox';
    }

    /**
     * Update the information element of the DataTable showing information about the
     * items selected. This is done by adding tags to the existing text
     *
     * @param {DataTable.Api} api DataTable to update
     * @private
     */
    function info(api, node) {
        if (api.select.style() === 'api' || api.select.info() === false) {
            return;
        }

        var rows = api.rows({ selected: true }).flatten().length;
        var columns = api.columns({ selected: true }).flatten().length;
        var cells = api.cells({ selected: true }).flatten().length;

        var add = function (el, name, num) {
            el.append(
                $('<span class="select-item"/>').append(
                    api.i18n(
                        'select.' + name + 's',
                        { _: '%d ' + name + 's selected', 0: '', 1: '1 ' + name + ' selected' },
                        num
                    )
                )
            );
        };

        var el = $(node);
        var output = $('<span class="select-info"/>');

        add(output, 'row', rows);
        add(output, 'column', columns);
        add(output, 'cell', cells);

        var existing = el.children('span.select-info');

        if (existing.length) {
            existing.remove();
        }

        if (output.text() !== '') {
            el.append(output);
        }
    }

    /**
     * Add a checkbox to the header for checkbox columns, allowing all rows to
     * be selected, deselected or just to show the state.
     *
     * @param {*} dt API
     * @param {*} headerCheckbox the header checkbox option
     */
    function initCheckboxHeader(dt, headerCheckbox) {
        var dtInternalColumns = dt.settings()[0].aoColumns;

        // Find any checkbox column(s)
        dt.columns().iterator('column', function (s, idx) {
            var col = dtInternalColumns[idx];

            // Checkbox columns have a rendering function with a given name
            if (!isCheckboxColumn(col)) {
                return;
            }
            var header = dt.column(idx).header();

            if (!$('input', header).length) {
                // If no checkbox yet, insert one
                var input = $('<input>')
                    .attr({
                        class: checkboxClass(true),
                        type: 'checkbox',
                        'aria-label': dt.i18n('select.aria.headerCheckbox') || 'Select all rows'
                    })
                    .appendTo(header)
                    .on('change', function () {
                        if (this.checked) {
                            if (headerCheckbox == 'select-page') {
                                dt.rows({ page: 'current' }).select()
                            } else {
                                dt.rows({ search: 'applied' }).select();
                            }
                        }
                        else {
                            dt.rows({ selected: true }).deselect();
                        }
                    })
                    .on('click', function (e) {
                        e.stopPropagation();
                    });

                // Update the header checkbox's state when the selection in the
                // table changes
                dt.on('draw select deselect', function (e, pass, type) {
                    if (type === 'row' || !type) {
                        var count = dt.rows({ selected: true }).count();
                        var search = dt.rows({ search: 'applied', selected: true }).count();
                        var available = headerCheckbox == 'select-page' ? dt.rows({ page: 'current' }).count() : dt.rows({ search: 'applied' }).count();

                        if (search && search <= count && search === available) {
                            input
                                .prop('checked', true)
                                .prop('indeterminate', false);
                        }
                        else if (search === 0 && count === 0) {
                            input
                                .prop('checked', false)
                                .prop('indeterminate', false);
                        }
                        else {
                            input
                                .prop('checked', false)
                                .prop('indeterminate', true);
                        }
                    }
                });
            }
        });
    }

    /**
     * Initialisation of a new table. Attach event handlers and callbacks to allow
     * Select to operate correctly.
     *
     * This will occur _after_ the initial DataTables initialisation, although
     * before Ajax data is rendered, if there is ajax data
     *
     * @param  {DataTable.settings} ctx Settings object to operate on
     * @private
     */
    function init(ctx) {
        var api = new DataTable.Api(ctx);
        ctx._select_init = true;

        // Row callback so that classes can be added to rows and cells if the item
        // was selected before the element was created. This will happen with the
        // `deferRender` option enabled.
        //
        // This method of attaching to `aoRowCreatedCallback` is a hack until
        // DataTables has proper events for row manipulation If you are reviewing
        // this code to create your own plug-ins, please do not do this!
        ctx.aoRowCreatedCallback.push(function (row, data, index) {
            var i, ien;
            var d = ctx.aoData[index];

            // Row
            if (d._select_selected) {
                $(row)
                    .addClass(ctx._select.className)
                    .find('input.' + checkboxClass(true)).prop('checked', true);
            }

            // Cells and columns - if separated out, we would need to do two
            // loops, so it makes sense to combine them into a single one
            for (i = 0, ien = ctx.aoColumns.length; i < ien; i++) {
                if (
                    ctx.aoColumns[i]._select_selected ||
                    (d._selected_cells && d._selected_cells[i])
                ) {
                    $(d.anCells[i]).addClass(ctx._select.className)
                }
            }
        }
        );

        // On Ajax reload we want to reselect all rows which are currently selected,
        // if there is an rowId (i.e. a unique value to identify each row with)
        api.on('preXhr.dt.dtSelect', function (e, settings) {
            if (settings !== api.settings()[0]) {
                // Not triggered by our DataTable!
                return;
            }

            // note that column selection doesn't need to be cached and then
            // reselected, as they are already selected
            var rows = api
                .rows({ selected: true })
                .ids(true)
                .filter(function (d) {
                    return d !== undefined;
                });

            var cells = api
                .cells({ selected: true })
                .eq(0)
                .map(function (cellIdx) {
                    var id = api.row(cellIdx.row).id(true);
                    return id ? { row: id, column: cellIdx.column } : undefined;
                })
                .filter(function (d) {
                    return d !== undefined;
                });

            // On the next draw, reselect the currently selected items
            api.one('draw.dt.dtSelect', function () {
                api.rows(rows).select();

                // `cells` is not a cell index selector, so it needs a loop
                if (cells.any()) {
                    cells.each(function (id) {
                        api.cells(id.row, id.column).select();
                    });
                }
            });
        });

        // Update the table information element with selected item summary
        api.on('info.dt', function (e, ctx, node) {
            // Store the info node for updating on select / deselect
            if (!ctx._select.infoEls.includes(node)) {
                ctx._select.infoEls.push(node);
            }

            info(api, node);
        });

        api.on('select.dtSelect.dt deselect.dtSelect.dt', function () {
            ctx._select.infoEls.forEach(function (el) {
                info(api, el);
            });

            api.state.save();
        });

        // Clean up and release
        api.on('destroy.dtSelect', function () {
            // Remove class directly rather than calling deselect - which would trigger events
            $(api.rows({ selected: true }).nodes()).removeClass(api.settings()[0]._select.className);

            $('input.' + checkboxClass(true), api.table().header()).remove();

            disableMouseSelection(api);
            api.off('.dtSelect');
            $('body').off('.dtSelect' + _safeId(api.table().node()));
        });
    }

    /**
     * Add one or more items (rows or columns) to the selection when shift clicking
     * in OS selection style
     *
     * @param  {DataTable.Api} dt   DataTable
     * @param  {string}        type Row or column range selector
     * @param  {object}        idx  Item index to select to
     * @param  {object}        last Item index to select from
     * @private
     */
    function rowColumnRange(dt, type, idx, last) {
        // Add a range of rows from the last selected row to this one
        var indexes = dt[type + 's']({ search: 'applied' }).indexes();
        var idx1 = indexes.indexOf(last);
        var idx2 = indexes.indexOf(idx);

        if (!dt[type + 's']({ selected: true }).any() && idx1 === -1) {
            // select from top to here - slightly odd, but both Windows and Mac OS
            // do this
            indexes.splice(indexes.indexOf(idx) + 1, indexes.length);
        }
        else {
            // reverse so we can shift click 'up' as well as down
            if (idx1 > idx2) {
                var tmp = idx2;
                idx2 = idx1;
                idx1 = tmp;
            }

            indexes.splice(idx2 + 1, indexes.length);
            indexes.splice(0, idx1);
        }

        if (!dt[type](idx, { selected: true }).any()) {
            // Select range
            dt[type + 's'](indexes).select();
        }
        else {
            // Deselect range - need to keep the clicked on row selected
            indexes.splice(indexes.indexOf(idx), 1);
            dt[type + 's'](indexes).deselect();
        }
    }

    /**
     * Clear all selected items
     *
     * @param  {DataTable.settings} ctx Settings object of the host DataTable
     * @param  {boolean} [force=false] Force the de-selection to happen, regardless
     *     of selection style
     * @private
     */
    function clear(ctx, force) {
        if (force || ctx._select.style === 'single') {
            var api = new DataTable.Api(ctx);

            api.rows({ selected: true }).deselect();
            api.columns({ selected: true }).deselect();
            api.cells({ selected: true }).deselect();
        }
    }

    /**
     * Select items based on the current configuration for style and items.
     *
     * @param  {object}             e    Mouse event object
     * @param  {DataTables.Api}     dt   DataTable
     * @param  {DataTable.settings} ctx  Settings object of the host DataTable
     * @param  {string}             type Items to select
     * @param  {int|object}         idx  Index of the item to select
     * @private
     */
    function typeSelect(e, dt, ctx, type, idx) {
        var style = dt.select.style();
        var toggleable = dt.select.toggleable();
        var isSelected = dt[type](idx, { selected: true }).any();

        if (isSelected && !toggleable) {
            return;
        }

        if (style === 'os') {
            if (e.ctrlKey || e.metaKey) {
                // Add or remove from the selection
                dt[type](idx).select(!isSelected);
            }
            else if (e.shiftKey) {
                if (type === 'cell') {
                    cellRange(dt, idx, ctx._select_lastCell || null);
                }
                else {
                    rowColumnRange(
                        dt,
                        type,
                        idx,
                        ctx._select_lastCell ? ctx._select_lastCell[type] : null
                    );
                }
            }
            else {
                // No cmd or shift click - deselect if selected, or select
                // this row only
                var selected = dt[type + 's']({ selected: true });

                if (isSelected && selected.flatten().length === 1) {
                    dt[type](idx).deselect();
                }
                else {
                    selected.deselect();
                    dt[type](idx).select();
                }
            }
        }
        else if (style == 'multi+shift') {
            if (e.shiftKey) {
                if (type === 'cell') {
                    cellRange(dt, idx, ctx._select_lastCell || null);
                }
                else {
                    rowColumnRange(
                        dt,
                        type,
                        idx,
                        ctx._select_lastCell ? ctx._select_lastCell[type] : null
                    );
                }
            }
            else {
                dt[type](idx).select(!isSelected);
            }
        }
        else {
            dt[type](idx).select(!isSelected);
        }
    }

    function _safeId(node) {
        return node.id.replace(/[^a-zA-Z0-9\-\_]/g, '-');
    }

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * DataTables selectors
     */

    // row and column are basically identical just assigned to different properties
    // and checking a different array, so we can dynamically create the functions to
    // reduce the code size
    $.each(
        [
            { type: 'row', prop: 'aoData' },
            { type: 'column', prop: 'aoColumns' }
        ],
        function (i, o) {
            DataTable.ext.selector[o.type].push(function (settings, opts, indexes) {
                var selected = opts.selected;
                var data;
                var out = [];

                if (selected !== true && selected !== false) {
                    return indexes;
                }

                for (var i = 0, ien = indexes.length; i < ien; i++) {
                    data = settings[o.prop][indexes[i]];

                    if (
                        data && (
                            (selected === true && data._select_selected === true) ||
                            (selected === false && !data._select_selected)
                        )
                    ) {
                        out.push(indexes[i]);
                    }
                }

                return out;
            });
        }
    );

    DataTable.ext.selector.cell.push(function (settings, opts, cells) {
        var selected = opts.selected;
        var rowData;
        var out = [];

        if (selected === undefined) {
            return cells;
        }

        for (var i = 0, ien = cells.length; i < ien; i++) {
            rowData = settings.aoData[cells[i].row];

            if (
                rowData && (
                    (selected === true &&
                        rowData._selected_cells &&
                        rowData._selected_cells[cells[i].column] === true) ||
                    (selected === false &&
                        (!rowData._selected_cells || !rowData._selected_cells[cells[i].column]))
                )
            ) {
                out.push(cells[i]);
            }
        }

        return out;
    });

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * DataTables API
     *
     * For complete documentation, please refer to the docs/api directory or the
     * DataTables site
     */

    // Local variables to improve compression
    var apiRegister = DataTable.Api.register;
    var apiRegisterPlural = DataTable.Api.registerPlural;

    apiRegister('select()', function () {
        return this.iterator('table', function (ctx) {
            DataTable.select.init(new DataTable.Api(ctx));
        });
    });

    apiRegister('select.blurable()', function (flag) {
        if (flag === undefined) {
            return this.context[0]._select.blurable;
        }

        return this.iterator('table', function (ctx) {
            ctx._select.blurable = flag;
        });
    });

    apiRegister('select.toggleable()', function (flag) {
        if (flag === undefined) {
            return this.context[0]._select.toggleable;
        }

        return this.iterator('table', function (ctx) {
            ctx._select.toggleable = flag;
        });
    });

    apiRegister('select.info()', function (flag) {
        if (flag === undefined) {
            return this.context[0]._select.info;
        }

        return this.iterator('table', function (ctx) {
            ctx._select.info = flag;
        });
    });

    apiRegister('select.items()', function (items) {
        if (items === undefined) {
            return this.context[0]._select.items;
        }

        return this.iterator('table', function (ctx) {
            ctx._select.items = items;

            eventTrigger(new DataTable.Api(ctx), 'selectItems', [items]);
        });
    });

    // Takes effect from the _next_ selection. None disables future selection, but
    // does not clear the current selection. Use the `deselect` methods for that
    apiRegister('select.style()', function (style) {
        if (style === undefined) {
            return this.context[0]._select.style;
        }

        return this.iterator('table', function (ctx) {
            if (!ctx._select) {
                DataTable.select.init(new DataTable.Api(ctx));
            }

            if (!ctx._select_init) {
                init(ctx);
            }

            ctx._select.style = style;

            // Add / remove mouse event handlers. They aren't required when only
            // API selection is available
            var dt = new DataTable.Api(ctx);
            disableMouseSelection(dt);

            if (style !== 'api') {
                enableMouseSelection(dt);
            }

            eventTrigger(new DataTable.Api(ctx), 'selectStyle', [style]);
        });
    });

    apiRegister('select.selector()', function (selector) {
        if (selector === undefined) {
            return this.context[0]._select.selector;
        }

        return this.iterator('table', function (ctx) {
            disableMouseSelection(new DataTable.Api(ctx));

            ctx._select.selector = selector;

            if (ctx._select.style !== 'api') {
                enableMouseSelection(new DataTable.Api(ctx));
            }
        });
    });

    apiRegister('select.last()', function (set) {
        let ctx = this.context[0];

        if (set) {
            ctx._select_lastCell = set;
            return this;
        }

        return ctx._select_lastCell;
    });

    apiRegisterPlural('rows().select()', 'row().select()', function (select) {
        var api = this;

        if (select === false) {
            return this.deselect();
        }

        this.iterator('row', function (ctx, idx) {
            clear(ctx);

            // There is a good amount of knowledge of DataTables internals in
            // this function. It _could_ be done without that, but it would hurt
            // performance (or DT would need new APIs for this work)
            var dtData = ctx.aoData[idx];
            var dtColumns = ctx.aoColumns;

            $(dtData.nTr).addClass(ctx._select.className);
            dtData._select_selected = true;

            for (var i = 0; i < dtColumns.length; i++) {
                var col = dtColumns[i];

                // Regenerate the column type if not present
                if (col.sType === null) {
                    api.columns().types()
                }

                if (isCheckboxColumn(col)) {
                    var cells = dtData.anCells;

                    // Make sure the checkbox shows the right state
                    if (cells && cells[i]) {
                        $('input.' + checkboxClass(true), cells[i]).prop('checked', true);
                    }

                    // Invalidate the sort data for this column, if not already done
                    if (dtData._aSortData !== null) {
                        dtData._aSortData[i] = null;
                    }
                }
            }
        });

        this.iterator('table', function (ctx, i) {
            eventTrigger(api, 'select', ['row', api[i]], true);
        });

        return this;
    });

    apiRegister('row().selected()', function () {
        var ctx = this.context[0];

        if (ctx && this.length && ctx.aoData[this[0]] && ctx.aoData[this[0]]._select_selected) {
            return true;
        }

        return false;
    });

    apiRegisterPlural('columns().select()', 'column().select()', function (select) {
        var api = this;

        if (select === false) {
            return this.deselect();
        }

        this.iterator('column', function (ctx, idx) {
            clear(ctx);

            ctx.aoColumns[idx]._select_selected = true;

            var column = new DataTable.Api(ctx).column(idx);

            $(column.header()).addClass(ctx._select.className);
            $(column.footer()).addClass(ctx._select.className);

            column.nodes().to$().addClass(ctx._select.className);
        });

        this.iterator('table', function (ctx, i) {
            eventTrigger(api, 'select', ['column', api[i]], true);
        });

        return this;
    });

    apiRegister('column().selected()', function () {
        var ctx = this.context[0];

        if (ctx && this.length && ctx.aoColumns[this[0]] && ctx.aoColumns[this[0]]._select_selected) {
            return true;
        }

        return false;
    });

    apiRegisterPlural('cells().select()', 'cell().select()', function (select) {
        var api = this;

        if (select === false) {
            return this.deselect();
        }

        this.iterator('cell', function (ctx, rowIdx, colIdx) {
            clear(ctx);

            var data = ctx.aoData[rowIdx];

            if (data._selected_cells === undefined) {
                data._selected_cells = [];
            }

            data._selected_cells[colIdx] = true;

            if (data.anCells) {
                $(data.anCells[colIdx]).addClass(ctx._select.className);
            }
        });

        this.iterator('table', function (ctx, i) {
            eventTrigger(api, 'select', ['cell', api.cells(api[i]).indexes().toArray()], true);
        });

        return this;
    });

    apiRegister('cell().selected()', function () {
        var ctx = this.context[0];

        if (ctx && this.length) {
            var row = ctx.aoData[this[0][0].row];

            if (row && row._selected_cells && row._selected_cells[this[0][0].column]) {
                return true;
            }
        }

        return false;
    });

    apiRegisterPlural('rows().deselect()', 'row().deselect()', function () {
        var api = this;

        this.iterator('row', function (ctx, idx) {
            // Like the select action, this has a lot of knowledge about DT internally
            var dtData = ctx.aoData[idx];
            var dtColumns = ctx.aoColumns;

            $(dtData.nTr).removeClass(ctx._select.className);
            dtData._select_selected = false;
            ctx._select_lastCell = null;

            for (var i = 0; i < dtColumns.length; i++) {
                var col = dtColumns[i];

                // Regenerate the column type if not present
                if (col.sType === null) {
                    api.columns().types()
                }

                if (isCheckboxColumn(col)) {
                    var cells = dtData.anCells;

                    // Make sure the checkbox shows the right state
                    if (cells && cells[i]) {
                        $('input.' + checkboxClass(true), dtData.anCells[i]).prop('checked', false);
                    }

                    // Invalidate the sort data for this column, if not already done
                    if (dtData._aSortData !== null) {
                        dtData._aSortData[i] = null;
                    }
                }
            }
        });

        this.iterator('table', function (ctx, i) {
            eventTrigger(api, 'deselect', ['row', api[i]], true);
        });

        return this;
    });

    apiRegisterPlural('columns().deselect()', 'column().deselect()', function () {
        var api = this;

        this.iterator('column', function (ctx, idx) {
            ctx.aoColumns[idx]._select_selected = false;

            var api = new DataTable.Api(ctx);
            var column = api.column(idx);

            $(column.header()).removeClass(ctx._select.className);
            $(column.footer()).removeClass(ctx._select.className);

            // Need to loop over each cell, rather than just using
            // `column().nodes()` as cells which are individually selected should
            // not have the `selected` class removed from them
            api.cells(null, idx)
                .indexes()
                .each(function (cellIdx) {
                    var data = ctx.aoData[cellIdx.row];
                    var cellSelected = data._selected_cells;

                    if (data.anCells && (!cellSelected || !cellSelected[cellIdx.column])) {
                        $(data.anCells[cellIdx.column]).removeClass(ctx._select.className);
                    }
                });
        });

        this.iterator('table', function (ctx, i) {
            eventTrigger(api, 'deselect', ['column', api[i]], true);
        });

        return this;
    });

    apiRegisterPlural('cells().deselect()', 'cell().deselect()', function () {
        var api = this;

        this.iterator('cell', function (ctx, rowIdx, colIdx) {
            var data = ctx.aoData[rowIdx];

            if (data._selected_cells !== undefined) {
                data._selected_cells[colIdx] = false;
            }

            // Remove class only if the cells exist, and the cell is not column
            // selected, in which case the class should remain (since it is selected
            // in the column)
            if (data.anCells && !ctx.aoColumns[colIdx]._select_selected) {
                $(data.anCells[colIdx]).removeClass(ctx._select.className);
            }
        });

        this.iterator('table', function (ctx, i) {
            eventTrigger(api, 'deselect', ['cell', api[i]], true);
        });

        return this;
    });

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Buttons
     */
    function i18n(label, def) {
        return function (dt) {
            return dt.i18n('buttons.' + label, def);
        };
    }

    // Common events with suitable namespaces
    function namespacedEvents(config) {
        var unique = config._eventNamespace;

        return 'draw.dt.DT' + unique + ' select.dt.DT' + unique + ' deselect.dt.DT' + unique;
    }

    function enabled(dt, config) {
        if (config.limitTo.indexOf('rows') !== -1 && dt.rows({ selected: true }).any()) {
            return true;
        }

        if (config.limitTo.indexOf('columns') !== -1 && dt.columns({ selected: true }).any()) {
            return true;
        }

        if (config.limitTo.indexOf('cells') !== -1 && dt.cells({ selected: true }).any()) {
            return true;
        }

        return false;
    }

    var _buttonNamespace = 0;

    $.extend(DataTable.ext.buttons, {
        selected: {
            text: i18n('selected', 'Selected'),
            className: 'buttons-selected',
            limitTo: ['rows', 'columns', 'cells'],
            init: function (dt, node, config) {
                var that = this;
                config._eventNamespace = '.select' + _buttonNamespace++;

                // .DT namespace listeners are removed by DataTables automatically
                // on table destroy
                dt.on(namespacedEvents(config), function () {
                    that.enable(enabled(dt, config));
                });

                this.disable();
            },
            destroy: function (dt, node, config) {
                dt.off(config._eventNamespace);
            }
        },
        selectedSingle: {
            text: i18n('selectedSingle', 'Selected single'),
            className: 'buttons-selected-single',
            init: function (dt, node, config) {
                var that = this;
                config._eventNamespace = '.select' + _buttonNamespace++;

                dt.on(namespacedEvents(config), function () {
                    var count =
                        dt.rows({ selected: true }).flatten().length +
                        dt.columns({ selected: true }).flatten().length +
                        dt.cells({ selected: true }).flatten().length;

                    that.enable(count === 1);
                });

                this.disable();
            },
            destroy: function (dt, node, config) {
                dt.off(config._eventNamespace);
            }
        },
        selectAll: {
            text: i18n('selectAll', 'Select all'),
            className: 'buttons-select-all',
            action: function (e, dt, node, config) {
                var items = this.select.items();
                var mod = config.selectorModifier;

                if (mod) {
                    if (typeof mod === 'function') {
                        mod = mod.call(dt, e, dt, node, config);
                    }

                    this[items + 's'](mod).select();
                }
                else {
                    this[items + 's']().select();
                }
            }
            // selectorModifier can be specified
        },
        selectNone: {
            text: i18n('selectNone', 'Deselect all'),
            className: 'buttons-select-none',
            action: function () {
                clear(this.settings()[0], true);
            },
            init: function (dt, node, config) {
                var that = this;
                config._eventNamespace = '.select' + _buttonNamespace++;

                dt.on(namespacedEvents(config), function () {
                    var count =
                        dt.rows({ selected: true }).flatten().length +
                        dt.columns({ selected: true }).flatten().length +
                        dt.cells({ selected: true }).flatten().length;

                    that.enable(count > 0);
                });

                this.disable();
            },
            destroy: function (dt, node, config) {
                dt.off(config._eventNamespace);
            }
        },
        showSelected: {
            text: i18n('showSelected', 'Show only selected'),
            className: 'buttons-show-selected',
            action: function (e, dt) {
                if (dt.search.fixed('dt-select')) {
                    // Remove existing function
                    dt.search.fixed('dt-select', null);

                    this.active(false);
                }
                else {
                    // Use a fixed filtering function to match on selected rows
                    // This needs to reference the internal aoData since that is
                    // where Select stores its reference for the selected state
                    var dataSrc = dt.settings()[0].aoData;

                    dt.search.fixed('dt-select', function (text, data, idx) {
                        // _select_selected is set by Select on the data object for the row
                        return dataSrc[idx]._select_selected;
                    });

                    this.active(true);
                }

                dt.draw();
            }
        }
    });

    $.each(['Row', 'Column', 'Cell'], function (i, item) {
        var lc = item.toLowerCase();

        DataTable.ext.buttons['select' + item + 's'] = {
            text: i18n('select' + item + 's', 'Select ' + lc + 's'),
            className: 'buttons-select-' + lc + 's',
            action: function () {
                this.select.items(lc);
            },
            init: function (dt) {
                var that = this;

                dt.on('selectItems.dt.DT', function (e, ctx, items) {
                    that.active(items === lc);
                });
            }
        };
    });

    // Note that DataTables 2.1 has more robust type detection, but we retain
    // backwards compatibility with 2.0 for the moment.
    DataTable.type('select-checkbox', {
        className: 'dt-select',
        detect: DataTable.versionCheck('2.1')
            ? {
                oneOf: function () {
                    return false; // no op
                },
                allOf: function () {
                    return false; // no op
                },
                init: function (settings, col, idx) {
                    return isCheckboxColumn(col);
                }
            }
            : function (data) {
                // Rendering function will tell us if it is a checkbox type
                return data === 'select-checkbox' ? data : false;
            },
        order: {
            pre: function (d) {
                return d === 'X' ? -1 : 0;
            }
        }
    });

    $.extend(true, DataTable.defaults.oLanguage, {
        select: {
            aria: {
                rowCheckbox: 'Select row'
            }
        }
    });

    DataTable.render.select = function (valueProp, nameProp) {
        var valueFn = valueProp ? DataTable.util.get(valueProp) : null;
        var nameFn = nameProp ? DataTable.util.get(nameProp) : null;

        var fn = function (data, type, row, meta) {
            var dtRow = meta.settings.aoData[meta.row];
            var selected = dtRow._select_selected;
            var ariaLabel = meta.settings.oLanguage.select.aria.rowCheckbox;

            if (type === 'display') {
                return $('<input>')
                    .attr({
                        'aria-label': ariaLabel,
                        class: checkboxClass(),
                        name: nameFn ? nameFn(row) : null,
                        type: 'checkbox',
                        value: valueFn ? valueFn(row) : null,
                        checked: selected
                    })
                    .on('input', function (e) {
                        // Let Select 100% control the state of the checkbox
                        e.preventDefault();

                        // And make sure this checkbox matches it's row as it is possible
                        // to check out of sync if this was clicked on to deselect a range
                        // but remains selected itself
                        this.checked = $(this).closest('tr').hasClass('selected');
                    })[0];
            }
            else if (type === 'type') {
                return 'select-checkbox';
            }
            else if (type === 'filter') {
                return '';
            }

            return selected ? 'X' : '';
        }

        // Workaround so uglify doesn't strip the function name. It is used
        // for the column type detection.
        fn._name = 'selectCheckbox';

        return fn;
    }

    // Legacy checkbox ordering
    DataTable.ext.order['select-checkbox'] = function (settings, col) {
        return this.api()
            .column(col, { order: 'index' })
            .nodes()
            .map(function (td) {
                if (settings._select.items === 'row') {
                    return $(td).parent().hasClass(settings._select.className).toString();
                }
                else if (settings._select.items === 'cell') {
                    return $(td).hasClass(settings._select.className).toString();
                }
                return false;
            });
    };

    $.fn.DataTable.select = DataTable.select;

    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Initialisation
     */

    // DataTables creation - check if select has been defined in the options. Note
    // this required that the table be in the document! If it isn't then something
    // needs to trigger this method unfortunately. The next major release of
    // DataTables will rework the events and address this.
    $(document).on('preInit.dt.dtSelect', function (e, ctx) {
        if (e.namespace !== 'dt') {
            return;
        }

        DataTable.select.init(new DataTable.Api(ctx));
    });


    return DataTable;
}));
/*! DataTables styling wrapper for Select
 * © SpryMedia Ltd - datatables.net/license
 */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery', 'datatables.net-dt', 'datatables.net-select'], function ($) {
            return factory($, window, document);
        });
    }
    else if (typeof exports === 'object') {
        // CommonJS
        var jq = require('jquery');
        var cjsRequires = function (root, $) {
            if (!$.fn.dataTable) {
                require('datatables.net-dt')(root, $);
            }

            if (!$.fn.dataTable.select) {
                require('datatables.net-select')(root, $);
            }
        };

        if (typeof window === 'undefined') {
            module.exports = function (root, $) {
                if (!root) {
                    // CommonJS environments without a window global must pass a
                    // root. This will give an error otherwise
                    root = window;
                }

                if (!$) {
                    $ = jq(root);
                }

                cjsRequires(root, $);
                return factory($, root, root.document);
            };
        }
        else {
            cjsRequires(window, jq);
            module.exports = factory(jq, window, window.document);
        }
    }
    else {
        // Browser
        factory(jQuery, window, document);
    }
}(function ($, window, document) {
    'use strict';
    var DataTable = $.fn.dataTable;




    return DataTable;
}));